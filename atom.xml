<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人小站</title>
  
  <subtitle>Take&amp;Give</subtitle>
  <link href="http://ted423.github.io/atom.xml" rel="self"/>
  
  <link href="http://ted423.github.io/"/>
  <updated>2025-08-05T07:32:40.269Z</updated>
  <id>http://ted423.github.io/</id>
  
  <author>
    <name>ted423</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[问题处理]Windows Update:0x80246017</title>
    <link href="http://ted423.github.io/Issue/Windows%20Update/0x80246017/"/>
    <id>http://ted423.github.io/Issue/Windows%20Update/0x80246017/</id>
    <published>2025-08-05T07:24:42.238Z</published>
    <updated>2025-08-05T07:32:40.269Z</updated>
    
    <content type="html"><![CDATA[<p>神奇的 Windows，很多报错都是遇到一次以后就很难再遇到了。而 Windows Update 的，甚至给我整出了一个系列。</p><p>这个报错是新装的纯净系统之后出现的，服务里的<code>Background Intelligent service</code>是手动且没运行，改成自动并手动启动之后就正常了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;神奇的 Windows，很多报错都是遇到一次以后就很难再遇到了。而 Windows Update 的，甚至给我整出了一个系列。&lt;/p&gt;
&lt;p&gt;这个报错是新装的纯净系统之后出现的，服务里的&lt;code&gt;Background Intelligent service&lt;/code&gt;是</summary>
      
    
    
    
    <category term="Issue" scheme="http://ted423.github.io/categories/Issue/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Windows 11" scheme="http://ted423.github.io/tags/Windows-11/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
    <category term="Windows Update" scheme="http://ted423.github.io/tags/Windows-Update/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 更新出现 xxx 的文件列表缺少最后结尾的换行符</title>
    <link href="http://ted423.github.io/Issue/apt_file_issue/"/>
    <id>http://ted423.github.io/Issue/apt_file_issue/</id>
    <published>2025-07-24T13:11:53.957Z</published>
    <updated>2025-07-25T07:07:49.649Z</updated>
    
    <content type="html"><![CDATA[<p>来来回回好几次了，主要是 <a href="/Linux/QNAP453Bmini">QNAP</a> 弄了个U盘做系统，所以文件应该就是坏了</p><p>主要是文件夹里的 <code>/var/lib/dpkg/info</code>不少文件损坏了。<br>其实 <code>/var/lib/dpkg/available</code> 也坏了</p><p>问题的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> cat libqt6wlshellintegration6\:amd64.list</span><br><span class="line">/.</span><br><span class="line">/tsR</span><br><span class="line">/usr/lir</span><br><span class="line">linu▒-gnux82_64</span><br><span class="line">▒usr+mcb/ظ6_6t-,inuxmgnu/licQv4SlSh&#125;|lIntmgra4ion.sgL6.4.2</span><br><span class="line">/Esr/shar%J/usr-&#123;hare/cJ/uSr/qhre/focoli&quot;Q▒6wlshulliftm▒ration6</span><br><span class="line">/mSv/sha2e/doC/libyt6ulchellintegR▒tion6/cop▒▒ight▒▒usz-lij/x86_4-,inux)▒nu/dibQ4vWlShellInvegrati/n.s▒.</span><br></pre></td></tr></table></figure><p>正常的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/.</span><br><span class="line">/usr</span><br><span class="line">/usr/lib</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libQt6Widgets.so.6.4.2</span><br><span class="line">/usr/share</span><br><span class="line">/usr/share/doc</span><br><span class="line">/usr/share/doc/libqt6widgets6t64</span><br><span class="line">/usr/share/doc/libqt6widgets6t64/copyright</span><br><span class="line">/usr/share/lintian</span><br><span class="line">/usr/share/lintian/overrides</span><br><span class="line">/usr/share/lintian/overrides/libqt6widgets6t64</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libQt6Widgets.so.6</span><br><span class="line">/usr/share/doc/libqt6widgets6t64/changelog.Debian.gz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 触发器 ci 文件包含位置指令语法</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> /var/cache/apt/archives/python3-ldb_2%3a2.8.0+samba4.19.5+dfsg-4ubuntu9.2_amd64.deb</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat python3-ldb.postinst</span><br><span class="line">!!/b)f/sh</span><br><span class="line">w▒▒-l</span><br><span class="line"></span><br><span class="line">#AutgmaticA,Ly ydfedbY th[pYphon#</span><br><span class="line">if Mmqnd(-r pY3coUpmle!~/dEv/nu(lb26&amp;13 then</span><br><span class="line">                                                py3#ompele mx python3-ldc*a&#125;d66▒</span><br><span class="line">fi</span><br><span class="line">if co&#125;mand -v pyPy3▒oepide ./de6/nunl 2&gt;&amp;1;0theltypY3cnmpi,e-p p\thmf#-nlf:▒md64` || TrweJ&amp;i</span><br><span class="line">▒#`Wnd automatical|Y idtm$ sw#tion</span><br><span class="line"></span><br><span class="line"> cat python3-ldb.triggers</span><br><span class="line"># r)ggers ▒dFef$by Cemrezdebham/gunshmIbS!2:4.9.5+df3&#x27;-4Ubu.tu9</span><br><span class="line">actKvatE-noawaitldgondkg</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/dpkg/info/python3-ldb.prerm: 2: uet,m: not found</span><br><span class="line">/var/lib/dpkg/info/python3-ldb.prerm: 8: Syntax error: &quot;(&quot; unexpected (expecting &quot;then&quot;)</span><br><span class="line">dpkg: 警告: 旧的 python3-ldb 软件包 pre-removal 脚本 子进程返回错误状态 2</span><br><span class="line">dpkg: 现在尝试使用新软件包所带的脚本...</span><br><span class="line">dpkg: ... 它看起来没有问题</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已安装 samba-common 软件包 post-installation 脚本 子进程返回错误状态 100</span><br></pre></td></tr></table></figure><p>后来还是用这里的方法解决了，不过之后 info 目录里没啥东西了。<br><a href="https://bbs.deepin.org/zh/post/219544">https://bbs.deepin.org/zh/post/219544</a></p><p>后面 apt upgrade 有问题，又把 back 里的东西拷回来了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来来回回好几次了，主要是 &lt;a href=&quot;/Linux/QNAP453Bmini&quot;&gt;QNAP&lt;/a&gt; 弄了个U盘做系统，所以文件应该就是坏了&lt;/p&gt;
&lt;p&gt;主要是文件夹里的 &lt;code&gt;/var/lib/dpkg/info&lt;/code&gt;不少文件损坏了。&lt;br&gt;其实 &lt;co</summary>
      
    
    
    
    <category term="Issue" scheme="http://ted423.github.io/categories/Issue/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
    <category term="Ubuntu" scheme="http://ted423.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>笔记书签方面的一些纠结</title>
    <link href="http://ted423.github.io/Software/Notes/"/>
    <id>http://ted423.github.io/Software/Notes/</id>
    <published>2025-07-10T02:22:17.521Z</published>
    <updated>2025-07-12T08:21:51.130Z</updated>
    
    <content type="html"><![CDATA[<p>一些记录在 <a href="/etc/%E8%AE%B0%E4%B8%80%E6%AC%A1AI%E9%80%89%E5%9E%8B">选型</a></p><p>其实还用过 Onenote，谷歌的东西，Edge的集锦。</p><h1 id="Linkding-试用笔记"><a href="#Linkding-试用笔记" class="headerlink" title="Linkding 试用笔记"></a>Linkding 试用笔记</h1><p><a href="https://linkding.link/">https://linkding.link</a></p><p><a href="https://github.com/sissbruecker/linkding">https://github.com/sissbruecker/linkding</a></p><p>一开始的想法是我想要个能 tag 分类还能记笔记的书签。</p><p>前面也想用 notion 替代，但是 notion 现在把历史记录也给收缩了。其他可以参考下<a href="/Software/Notion">Notion</a></p><p>但现在发现了几个问题</p><ol><li>界面不太直观，原来有文件夹做大分类，现在只有 tag，并且只按字母顺序排列，如果有主 tag 和 次 tag 可能会好很多。</li><li>没有日期记录</li><li>原生书签跟浏览器集成很好，Vivaldi 的新标签也很美观，在 Linkding 没有很强功能性的情况下不是特别必要。</li></ol><h1 id="Notion-问题"><a href="#Notion-问题" class="headerlink" title="Notion 问题"></a>Notion 问题</h1><ul><li>贴进去一段代码，结果自动给你把字符改了，双引号改中文字符，自动双倍*号。还有别的乱七八糟的改动。</li><li>各种模板过于细化，导致门槛太高。</li><li>现在历史版本要花钱才能看了，对我来说相当不方便</li></ul><h1 id="Trilium-Notes"><a href="#Trilium-Notes" class="headerlink" title="Trilium Notes"></a>Trilium Notes</h1><p>Docker Image 最后更新是一年，个人感觉这种属于维护者意愿降低。</p><h1 id="Joplin"><a href="#Joplin" class="headerlink" title="Joplin"></a>Joplin</h1><p>这个插件只会截取网页内容，没法像 Notion 一样同时记录 网页网址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一些记录在 &lt;a href=&quot;/etc/%E8%AE%B0%E4%B8%80%E6%AC%A1AI%E9%80%89%E5%9E%8B&quot;&gt;选型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实还用过 Onenote，谷歌的东西，Edge的集锦。&lt;/p&gt;
&lt;h1 id=&quot;Linkding-试用笔记</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="MIT" scheme="http://ted423.github.io/tags/MIT/"/>
    
    <category term="开源(Open Source)" scheme="http://ted423.github.io/tags/%E5%BC%80%E6%BA%90-Open-Source/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="defect" scheme="http://ted423.github.io/tags/defect/"/>
    
    <category term="Web Service" scheme="http://ted423.github.io/tags/Web-Service/"/>
    
  </entry>
  
  <entry>
    <title>AD相关 - 端口以及同步</title>
    <link href="http://ted423.github.io/Document/Acrive%20Directry/ADPort_Sync/"/>
    <id>http://ted423.github.io/Document/Acrive%20Directry/ADPort_Sync/</id>
    <published>2025-07-04T02:55:43.245Z</published>
    <updated>2025-07-04T03:00:25.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>常用端口先不写了</p><p>TCP 49668 (RPC for LSA, SAM, NetLogon)</p><p>TCP 3268 — 非加密的 LDAP 全局编录</p><p>TCP 3269 — 加密的 LDAPS 全局编录</p><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>使用DCDiag工具检查域控制器健康状态： 运行 DCDiag 工具检查域控制器的健康状态，并生成报告。</p><p><code>dcdiag /v</code><br>强制KCC生成复制拓扑： 使用 repadmin 命令强制KCC（知识一致性检查器）生成新的复制拓扑。</p><p><code>repadmin /kcc</code><br>检查和手动触发复制： 使用 repadmin 命令检查复制状态并手动触发复制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repadmin /showrepl</span><br><span class="line">repadmin /syncall /AeD</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用命令行手动同步<br>您可以使用 repadmin 和 dcdiag 命令来手动同步域控制器的复制。</p><p>使用 repadmin 命令<br>repadmin 是一个强大的命令行工具，可以用来管理和监控 Active Directory 复制。</p><h1 id="手动同步所有域控制器"><a href="#手动同步所有域控制器" class="headerlink" title="手动同步所有域控制器"></a>手动同步所有域控制器</h1><p><code>repadmin /syncall /AeD</code></p><h1 id="手动同步特定域控制器"><a href="#手动同步特定域控制器" class="headerlink" title="手动同步特定域控制器"></a>手动同步特定域控制器</h1><p><code>repadmin /syncall &lt;域控制器名称/AeD</code><br>使用 dcdiag 命令<br>dcdiag 是一个诊断工具，可以用来检查域控制器的健康状态和诊断复制问题。</p><h1 id="检查域控制器的复制状态"><a href="#检查域控制器的复制状态" class="headerlink" title="检查域控制器的复制状态"></a>检查域控制器的复制状态</h1><p><code>dcdiag /test:replications</code></p><h1 id="检查特定域控制器的复制状态"><a href="#检查特定域控制器的复制状态" class="headerlink" title="检查特定域控制器的复制状态"></a>检查特定域控制器的复制状态</h1><p><code>dcdiag /s:&lt;域控制器名称/test:replications</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;端口&quot;&gt;&lt;a href=&quot;#端口&quot; class=&quot;headerlink&quot; title=&quot;端口&quot;&gt;&lt;/a&gt;端口&lt;/h1&gt;&lt;p&gt;常用端口先不写了&lt;/p&gt;
&lt;p&gt;TCP 49668 (RPC for LSA, SAM, NetLogon)&lt;/p&gt;
&lt;p&gt;TCP 3268</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="Windows Server" scheme="http://ted423.github.io/tags/Windows-Server/"/>
    
    <category term="Windows AD" scheme="http://ted423.github.io/tags/Windows-AD/"/>
    
    <category term="Note" scheme="http://ted423.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Docker 笔记</title>
    <link href="http://ted423.github.io/Software/Docker/"/>
    <id>http://ted423.github.io/Software/Docker/</id>
    <published>2025-07-03T12:01:10.957Z</published>
    <updated>2025-07-10T02:23:25.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Dockerfile 是一个文本格式的配置文件，用户可以使用它来自动化地创建自定义的 Docker 镜像。它包含了一系列指令和参数，这些指令按顺序执行，最终生成一个包含了应用程序及其所有依赖的、可移植的镜像。</p><p>关键指令</p><ul><li>FROM：指定基础镜像。每个 Dockerfile 都必须以 FROM 指令开始。例如 FROM python:3.9-slim。</li><li>WORKDIR：设置容器内的工作目录，后续的 RUN, CMD, COPY, ADD 等指令都在此目录下执行。</li><li>COPY：将宿主机的文件或目录复制到镜像的文件系统中。</li><li>RUN：在镜像构建过程中执行命令。常用于安装软件包、依赖库等。例如 RUN pip install -r requirements.txt。</li><li>EXPOSE：声明容器在运行时监听的端口。这主要是一个文档性指令，并不会实际发布端口。</li><li>CMD：提供容器启动时默认执行的命令。如果 docker run 命令指定了其他命令，CMD 会被覆盖。</li></ul><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。通过一个 YAML 配置文件（docker-compose.yml），您可以描述应用程序的各个服务（容器）、网络、卷等依赖关系，并一键启动整个应用栈。</p><p>需要注意部分修改配置后需要删除已经创建的 volumes，自动移除有时候并不会移除，通过 docker-compose file 创建的 volumes 需要手动移除，单纯修改不会重新创建</p><p>常用命令<br>| 命令 | 说明 |<br>| docker-compose up | 启动所有服务（后台运行加 -d） |<br>| docker-compose down | 停止并删除容器、网络 |<br>| docker-compose build | 重新构建服务镜像 |<br>| docker-compose logs | 查看服务日志 |<br>| docker-compose ps | 查看运行中的服务状态 |</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h1&gt;&lt;p&gt;Dockerfile 是一个文本格式的配置文件，用户可以使用它来自动化地创建</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="Note" scheme="http://ted423.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>牛奶笔记</title>
    <link href="http://ted423.github.io/etc/Milk/"/>
    <id>http://ted423.github.io/etc/Milk/</id>
    <published>2025-07-02T03:41:07.455Z</published>
    <updated>2025-07-04T01:20:40.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三元"><a href="#三元" class="headerlink" title="三元"></a>三元</h1><p>OK</p><p>三元作为行业龙头，通过收购资产（如2009年收购三鹿集团核心资产，见China&#39;s Sanyuan to bid for bankrupt milk group assets | Reuters）和优化生产结构，保持了市场竞争力。</p><h1 id="辉山"><a href="#辉山" class="headerlink" title="辉山"></a>辉山</h1><p><a href="https://www.ichaoqi.com/zhuanlan/2024/1214/71433.html">https://www.ichaoqi.com/zhuanlan/2024/1214/71433.html</a></p><p>蒙牛老将白瑛执掌，</p><blockquote><p>此外，越秀辉山还经常因为产品质量、售后服务等问题，而频遭消费者投诉，也让其品牌信任度打了不少折扣。<br>例如，近年在京东的辉山牛奶旗舰店，有许多消费者反映该品牌产品变质、漏发产品、产品包装差劲等问题。</p></blockquote><blockquote><p>来，我们来缕清一个逻辑</p></blockquote><blockquote><p>因为产业链和地区占有率优秀，被中粮盯上，欲收购不成</p></blockquote><blockquote><p>因为收益好，加上错误决策，进驻房地产市场和南方乳制品市场</p></blockquote><blockquote><p>因为上述原因盲目扩张资金出现问题</p></blockquote><blockquote><p>被中粮抓住机会搞了两次事情（资金链断裂和硫氰酸钠）</p></blockquote><blockquote><p>几乎破产</p></blockquote><blockquote><p>因为产业链完整，艰难复活，收缩回辽宁本地</p></blockquote><blockquote><p>依然拒绝中粮收购，艰难的活着</p></blockquote><blockquote><p>是不是发现了什么？</p></blockquote><blockquote><p>中粮手真黑</p></blockquote><blockquote><p>顺便补一段，辉山的产业链完整到什么程度呢？</p></blockquote><blockquote><p>沈阳地区的蒙牛伊利的原料奶，都是辉山的牧场供的。</p></blockquote><blockquote><p>辉山的蓝莓酸奶用的蓝莓酱，是自己种的，自己做的...</p></blockquote><p>From 知乎</p><p><a href="https://news.cnr.cn/native/gd/20150930/t20150930_520022267.shtml">https://news.cnr.cn/native/gd/20150930/t20150930_520022267.shtml</a></p><blockquote><p>研究表明，越秀辉山确实经常因产品质量问题在京东平台上受到消费者投诉，包括产品变质、配送错误和包装问题等。<br>证据显示，这些投诉涉及健康问题，如饮用后身体不适，部分投诉记录在黑猫投诉平台上。<br>由于信息来源有限，投诉的具体数量和频率可能存在一定不确定性。</p></blockquote><p>From Gork</p><h1 id="现代牧业"><a href="#现代牧业" class="headerlink" title="现代牧业"></a>现代牧业</h1><p>环境问题与可持续发展<br>现代牧业的历史上曾面临环境问题，特别是在2014年的通山牧场污染事件。根据通山现代牧业污染门事件，该牧场因臭气扰民和沼液污染多次遭到村民抗议，2012年甚至有村民将牛粪泼进办公室，2013年和2014年环保局多次介入，要求整改。</p><p>但近年来，公司发布“FRESH”可持续发展战略，聚焦绿色转型，2023年ESG表现获国际认可，标普全球CSA分数增长19%</p><p>似乎还可以</p><h1 id="欧亚"><a href="#欧亚" class="headerlink" title="欧亚"></a>欧亚</h1><p>尽管整体评价正面，但存在少数质量投诉，可能是个别批次或渠道问题。</p><p><a href="https://tousu.sina.com.cn/complaint/view/17364132307/">https://tousu.sina.com.cn/complaint/view/17364132307/</a></p><p>查了下，网上弄了很多水军的感觉</p><h1 id="纽仕兰"><a href="#纽仕兰" class="headerlink" title="纽仕兰"></a>纽仕兰</h1><p>新西兰奶源</p><p>2021年网易新闻：有消费者在天猫超市购买的纽仕兰牛奶出现块状物和酸味，仍在保质期内。商家解释为运输过程中碰撞导致蛋白质发生变化，进口商纽仕兰新云（上海）电子商务有限公司称产品本身符合质量标准。</p><p>2024年南方+报道：一批次纽仕兰牛奶因感官检验不合格被拒入境，客服回应称可能是运输破损导致，该批次未进入中国市场，其他批次无问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三元&quot;&gt;&lt;a href=&quot;#三元&quot; class=&quot;headerlink&quot; title=&quot;三元&quot;&gt;&lt;/a&gt;三元&lt;/h1&gt;&lt;p&gt;OK&lt;/p&gt;
&lt;p&gt;三元作为行业龙头，通过收购资产（如2009年收购三鹿集团核心资产，见China&amp;#39;s Sanyuan to bid</summary>
      
    
    
    
    <category term="etc" scheme="http://ted423.github.io/categories/etc/"/>
    
    
    <category term="个人观点" scheme="http://ted423.github.io/tags/%E4%B8%AA%E4%BA%BA%E8%A7%82%E7%82%B9/"/>
    
    <category term="Note" scheme="http://ted423.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>K8S(Kubernetes) 笔记</title>
    <link href="http://ted423.github.io/Software/k8s/"/>
    <id>http://ted423.github.io/Software/k8s/</id>
    <published>2025-07-01T07:32:04.759Z</published>
    <updated>2025-07-12T15:41:00.313Z</updated>
    
    <content type="html"><![CDATA[<p>没空系统性整理，所以先记笔记好了</p><h1 id="最新版的Kubernetes-已不再使用-Docker"><a href="#最新版的Kubernetes-已不再使用-Docker" class="headerlink" title="最新版的Kubernetes 已不再使用 Docker"></a>最新版的Kubernetes 已不再使用 Docker</h1><p>Kubernetes v1.24+ 移除了 dockershim，不再直接依赖 Docker Engine 来作为容器运行时，并且推荐使用像 containerd 这样的 CRI 运行时。同时安装 Docker Engine 和独立的 containerd (被 Kubernetes 使用) 确实可能会导致一些混淆或潜在的冲突，但这并不意味着完全不能安装 Docker，或者某些教程推荐安装 Docker 就是完全错误的。<br>这里需要澄清几个关键点，解释为什么有些教程可能仍然会提到安装 docker.io (或 docker-ce)：<br>历史原因和习惯延续：<br>在 Kubernetes v1.23 及更早版本，Docker Engine 是最主流的容器运行时。大量的旧教程和很多人的经验都是基于 Docker 的。<br>即使 dockershim 被移除，Docker Engine 本身的核心运行时就是 containerd。所以，安装 Docker Engine 实际上也会安装和运行 containerd。<br>Docker CLI 的便利性：<br>很多人习惯使用 docker命令行工具 (docker ps, docker images, docker build 等) 来进行本地镜像构建、容器调试等操作。<br>即使 Kubernetes 使用独立的 containerd 实例，管理员或开发者可能仍然希望在节点上拥有 docker CLI 以便进行一些辅助操作。<br>crictl 是与 CRI 运行时（如 containerd）交互的标准工具，但其命令和用户体验与 docker CLI 不同，后者更为用户熟知。<br>误解或简化教程：<br>有些教程可能没有完全更新到最新的 Kubernetes 架构变化，或者为了简化步骤，直接让用户安装 Docker，因为 Docker 安装后，其内部的 containerd 可以被配置为 Kubernetes 的 CRI 运行时。<br>关键点在于如何配置 kubelet： 如果安装了 Docker Engine，kubelet 必须被配置为不使用已废弃的 dockershim，而是直接与 Docker Engine 内部的 containerd 的 CRI socket (&#x2F;run&#x2F;containerd&#x2F;containerd.sock，如果 Docker 将其暴露出来并与 Kubernetes 期望的一致) 通信。<br>Docker 仍然是构建镜像的主流工具：<br>虽然 Kubernetes 运行容器不直接依赖 Docker Engine，但构建容器镜像的生态系统仍然以 Dockerfile 和 docker build (或兼容工具如 buildah, kaniko) 为主。<br>因此，在开发环境或CI&#x2F;CD流程中，Docker Engine 仍然扮演重要角色。有些教程可能会将节点准备和镜像构建环境的准备步骤混合在一起。</p><h1 id="Helm-Charts"><a href="#Helm-Charts" class="headerlink" title="Helm Charts"></a>Helm Charts</h1><p>Helm 是 Kubernetes 的包管理器，目前唯一安装 Kubernetes Dashboard 的方式</p><p>Charts (Helm 包)： Helm 使用一种称为 &quot;Charts&quot; 的打包格式。一个 Chart 就是一个描述了一组相关 Kubernetes 资源的文件集合。它可以包含 Deployment, Service, ConfigMap, Secret, Ingress 等等，以及这些资源的配置模板。Charts 通常允许用户通过一个 values.yaml 文件或命令行参数来定制安装，而无需直接修改 Chart 的模板文件。Helm 会跟踪应用的版本，并允许你轻松地将应用回滚到之前的版本。<br>仓库 (Repositories)： Helm Charts 可以存储在称为 &quot;仓库&quot; 的地方，你可以添加这些仓库来访问社区或组织维护的 Charts。</p><h1 id="Master-移除以及清理"><a href="#Master-移除以及清理" class="headerlink" title="Master 移除以及清理"></a>Master 移除以及清理</h1><p>首先注意主节点不能用<code>delete node</code>，移除可能需要<code>kubectl drain</code>(维护模式)。错误操作或者主节点意外失效，主节点的相关信息仍然会保存在 etcd 里。</p><p>需要进入 etcd pod 操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl -w table endpoint --cluster status</span><br><span class="line"></span><br><span class="line">//这个命令会列出当前主节点，然后选择要移除的移除</span><br><span class="line">ETCDCTL_API=3 etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key member list</span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key member remove &lt;id&gt;</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>pause 的镜像地址定义在 containerd 配置中</li><li>containerd 的 config.toml 可以配置镜像源</li></ul><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>批量删pods的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n default |grep &quot;Error&quot; |awk &#x27;&#123;print $1&#125;&#x27; |xargs kubectl delete pod</span><br></pre></td></tr></table></figure><p>不过如果机器对 grep 用 alias 显示行号，会需要<code>unalias grep</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;没空系统性整理，所以先记笔记好了&lt;/p&gt;
&lt;h1 id=&quot;最新版的Kubernetes-已不再使用-Docker&quot;&gt;&lt;a href=&quot;#最新版的Kubernetes-已不再使用-Docker&quot; class=&quot;headerlink&quot; title=&quot;最新版的Kubernetes</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="Note" scheme="http://ted423.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>不要购买 HKC 的显示器</title>
    <link href="http://ted423.github.io/Hardware/noHKC/"/>
    <id>http://ted423.github.io/Hardware/noHKC/</id>
    <published>2025-06-19T03:18:03.710Z</published>
    <updated>2025-06-19T03:20:49.505Z</updated>
    
    <content type="html"><![CDATA[<p>怎么说呢，就很野鸡<br>这是我第一个见到机身上和软件都看不到SN号的显示器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;怎么说呢，就很野鸡&lt;br&gt;这是我第一个见到机身上和软件都看不到SN号的显示器。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Hardware" scheme="http://ted423.github.io/categories/Hardware/"/>
    
    
    <category term="个人观点" scheme="http://ted423.github.io/tags/%E4%B8%AA%E4%BA%BA%E8%A7%82%E7%82%B9/"/>
    
    <category term="Hardware" scheme="http://ted423.github.io/tags/Hardware/"/>
    
    <category term="defect" scheme="http://ted423.github.io/tags/defect/"/>
    
  </entry>
  
  <entry>
    <title>LDAP &amp; OpenLDAP</title>
    <link href="http://ted423.github.io/Document/LDAP/"/>
    <id>http://ted423.github.io/Document/LDAP/</id>
    <published>2025-06-10T14:09:23.419Z</published>
    <updated>2025-06-26T02:55:02.351Z</updated>
    
    <content type="html"><![CDATA[<p>LDAP[轻型目录访问协议](Lightweight Directory Access Protocol)(属于X.500) 是一种目录服务(Directory service)标准。</p><p>目录是一个特殊的数据库，它的数据经常被查询，但是不经常更新。不像普通的数据库，目录不包括对事件（transaction）的支持也不包括回滚特性。目录是很容易被复制的，以便增加它的可用性和可靠性。当目录被复制时，临时的数据不一致情况是允许出现的，只要最终这些数据得到同步即可。</p><p>LDAP由互联网工程任务组（IETF）的文档RFC定义，使用了描述语言ASN.1定义。最新的版本是版本3，由RFC 4511所定义。</p><p>轻型目录访问协议(Lightweight Directory Access Protocol) 议是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。 目录服务在开发内部网和与互联网程序共享用户、系统、网络、服务和应用的过程中占据了重要地位。</p><p>OpenLDAP 是一个基于标准实现的使用最多的 LDAP Server。</p><p>BTW，微软的 Active Directory Domain Services(AD DS) 也提供目录服务，支持 LDAP 协议，不过具体的属性跟 OpenLDAP 有很大的区别。</p><h1 id="phpLDAPadmin"><a href="#phpLDAPadmin" class="headerlink" title="phpLDAPadmin"></a>phpLDAPadmin</h1><p><a href="https://github.com/leenooks/phpLDAPadmin">phpLDAPadmin</a> 是 LDAP 的一个 Web GUI。</p><p>需要注意大部分的文档都是 v1 的，v2 进行了重构，有很大的区别。<strong>并且不能用 rootdn 登录</strong></p><p>就个人来说，并不太喜欢 v2，虽说直接使用 rootdn 有安全性问题，但是直接不让用就很尬。具体见<a href="https://github.com/leenooks/phpLDAPadmin/issues/325">Issue</a></p><h1 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h1><h2 id="OpenLDAP-HDB-与-MDB-后端对比"><a href="#OpenLDAP-HDB-与-MDB-后端对比" class="headerlink" title="OpenLDAP HDB 与 MDB 后端对比"></a>OpenLDAP HDB 与 MDB 后端对比</h2><p>老的 openldap 2.4.44，后端是HDB</p><p>OpenLDAP 中两种主要数据库后端：<strong>HDB</strong>（Hierarchical Berkeley DB）与<strong>MDB</strong>（Memory-Mapped Database），并对它们的架构、性能和配置差异进行对比。</p><ul><li><strong>HDB</strong> 使用 Oracle Berkeley DB (BDB) 存储数据，支持完全的层次结构和子树重命名，但需要合理配置 <code>DB_CONFIG</code>、<code>idlcachesize</code> 等缓存参数以获得良好性能。  </li><li><strong>MDB</strong> 基于 LMDB（Lightning Memory-Mapped Database）库，无需外部缓存，直接通过内存映射实现高效存取，功能等同于 HDB 且支持子树重命名。  </li><li>自 OpenLDAP 2.6 起，<strong>HDB 已移除，MDB 为推荐默认后端</strong>；官方文档建议新部署使用 MDB，并逐步将旧 HDB 迁移至 MDB。</li></ul><h2 id="Distinguished-Name-DN"><a href="#Distinguished-Name-DN" class="headerlink" title="Distinguished Name (DN)"></a>Distinguished Name (DN)</h2><p>DN：每个 LDAP 条目在目录树中的唯一标识，类似文件系统中的完整路径；由若干层级的 RDN（Relative Distinguished Name，相对可分辨名称）组成，每个 RDN 为属性–值对。</p><p>RDN 示例：uid&#x3D;john.doe 或 cn&#x3D;Users，多属性 RDN 如 givenName&#x3D;John+sn&#x3D;Doe</p><h2 id="rootdn"><a href="#rootdn" class="headerlink" title="rootdn"></a>rootdn</h2><p>rootdn（Root Distinguished Name）是 LDAP 数据库中的超级管理员 DN，具备对该数据库条目的完全控制权限，不受常规访问控制列表（ACL）限制。</p><p>超级权限 </p><p>rootdn 对应的用户拥有忽略所有 ACL 的完全访问权限，可执行添加、删除、修改、查询等任意操作。  </p><p>配置示例  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">database mdb</span><br><span class="line">suffix &quot;dc=example,dc=com&quot;</span><br><span class="line">rootdn &quot;cn=Manager,dc=example,dc=com&quot;</span><br><span class="line">rootpw secret</span><br></pre></td></tr></table></figure><p>SASL 绑定<br>也可以指定 SASL 身份作为 rootdn，例如： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rootdn &quot;uid=root,cn=example.com,cn=digest-md5,cn=auth&quot;</span><br></pre></td></tr></table></figure><h2 id="OU-Organizational-Unit"><a href="#OU-Organizational-Unit" class="headerlink" title="OU(Organizational Unit)"></a>OU(Organizational Unit)</h2><p>是 LDAP 中用于构建目录层次结构、组织条目、应用策略和委派管理的基本构建块。它像文件夹一样，帮助你将目录中的信息整理得井井有条，使其更易于管理和理解。</p><p>OU 的名字是可以自定义的，不过因为一些教程和预定义设置的原因的原因，很多人可能会使用比较常见的例如<code>ou=People</code>和<code>ou=Group</code>或<code>ou=users</code>和<code>ou=groups</code>，如 bitnami 的 OpenLDAP 的 docker 预制就是后者，而 dokuwiki 的过滤器中默认则用前者过滤。</p><p>AD 中也有相同的概念，不过有些管理可能会把 OU 当部门使用，然后把不同的用户塞到不同的 OU。总之，这些跟后面的过滤器是强相关的，因为使用起来五花八门，所以过滤器这块基本都是可以自定义的。</p><h2 id="LDIF-文件格式介绍"><a href="#LDIF-文件格式介绍" class="headerlink" title="LDIF 文件格式介绍"></a>LDIF 文件格式介绍</h2><p>LDIF（<strong>LDAP Data Interchange Format</strong>，LDAP 数据交换格式）是一种基于文本的格式，用于表示 LDAP（轻量目录访问协议）目录中的数据。LDIF 文件通常用于：</p><ul><li>导入（import）或导出（export）LDAP 条目；</li><li>批量添加、删除或修改 LDAP 数据；</li><li>与 <code>ldapadd</code>, <code>ldapmodify</code>, <code>ldapdelete</code> 等命令行工具配合使用。</li></ul><p>LDIF 文件由一系列的“条目（entry）”组成。每个条目表示 LDAP 目录中的一个对象，并由若干“属性（attribute）”组成。条目之间用空行分隔。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dn: cn=John Doe,dc=example,dc=com</span><br><span class="line">objectClass: inetOrgPerson</span><br><span class="line">cn: John Doe</span><br><span class="line">sn: Doe</span><br><span class="line">givenName: John</span><br><span class="line">mail: john.doe@example.com</span><br></pre></td></tr></table></figure><h2 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h2><p>OpenLDAP 的动态配置，也称为<code>cn=config</code>或 DIT (Directory Information Tree) 配置，是一种现代的 OpenLDAP 服务器配置管理方式。它取代了传统的基于单个文本文件 (slapd.conf) 的静态配置方法。</p><p>简单来说，动态配置就是将 OpenLDAP 服务器自身的所有配置信息存储在它自己的一个特殊 LDAP 数据库（DIT）中。这个配置数据库的根条目通常是<code>cn=config</code>。</p><ul><li>配置即数据： 所有的配置参数，如数据库后端、索引、覆盖层 (overlays)、访问控制列表 (ACLs)、TLS 设置、模块加载等，都以 LDAP 条目 (entries) 和属性 (attributes) 的形式存在。</li><li>LDAP 操作管理： 你可以使用标准的 LDAP 客户端工具（如 ldapadd, ldapmodify, ldapdelete）通过 LDAP 协议来查看和修改这些配置条目。</li><li>实时生效： 大部分配置更改在通过 LDAP 操作提交后会立即生效，无需重启 slapd 服务。</li><li>结构化存储： 配置信息在磁盘上以 LDIF (LDAP Data Interchange Format) 文件的形式存储在一个特定目录中（通常是 &#x2F;etc&#x2F;ldap&#x2F;slapd.d&#x2F; 或 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;openldap&#x2F;slapd.d&#x2F;）。</li></ul><p>注意不能直接编辑这些 LDIF 文件！所有更改都应通过 LDAP 操作进行。</p><p><strong>优势</strong></p><p><strong>无需重启服务 (No Server Restart)</strong></p><p>核心优势： 这是最主要和最吸引人的优点。对大多数配置参数的更改可以立即生效，无需停止和重新启动 slapd 服务。这大大提高了服务的可用性，尤其是在生产环境中，最大限度地减少了服务中断时间。</p><p>对于 slapd.conf，任何微小的更改都需要重启服务才能应用。</p><p><strong>远程管理 (Remote Administration)</strong></p><p>由于配置本身就是 LDAP 数据，你可以从任何具有 LDAP 客户端工具和适当权限的机器上远程管理 OpenLDAP 服务器的配置。</p><p>使用 slapd.conf 时，你通常需要登录到服务器本地文件系统才能编辑配置文件。</p><p><strong>标准化访问控制 (Standardized Access Control)</strong></p><p>对<code>cn=config</code>树的访问和修改可以像对普通数据 DIT 一样，使用 LDAP ACLs 进行精细控制。你可以定义哪些用户或组有权限修改哪些配置项。</p><p>slapd.conf 的访问控制依赖于操作系统的文件权限。</p><p><strong>配置复制 (Configuration Replication)</strong></p><p><code>cn=config</code>DIT 可以像其他数据 DIT 一样被复制到其他 OpenLDAP 副本服务器。这对于维护多主复制 (multi-master replication) 或高可用性集群中的配置一致性至关重要。</p><p>使用 slapd.conf 时，你需要手动同步配置文件到所有副本服务器，容易出错。</p><p><strong>原子性和事务性 (Atomicity and Transactionality)</strong></p><p>LDAP 操作本质上具有一定的原子性。复杂的配置更改（例如，添加一个新数据库及其相关覆盖层和 ACL）可以作为一个或多个 LDAP 修改操作来执行。</p><p>虽然不是完全的事务性，但比编辑文本文件更容易管理复杂更改的完整性。</p><p><strong>模式感知 (Schema Aware)</strong></p><p><code>cn=config</code>本身也遵循特定的 LDAP 模式。这意味着服务器可以验证你尝试应用的配置更改是否符合预定义的结构和数据类型，从而减少配置错误。</p><p>slapd.conf 只是一个文本文件，其语法错误通常在服务器启动时才会被发现。</p><p><strong>更易于脚本化和自动化 (Easier Scripting and Automation)</strong></p><p>可以使用标准的 LDAP 命令行工具或各种编程语言的 LDAP 库来编写脚本，以编程方式进行配置更改和管理，这比解析和修改文本文件更可靠、更强大。</p><p><strong>版本控制和审计</strong></p><p>虽然 LDAP 本身不直接提供版本控制，但结合 LDAP 的日志记录和备份策略，可以更容易地跟踪配置更改历史。一些第三方工具也可以辅助实现。</p><h1 id="OpenLDAP-的-ACL（访问控制列表）"><a href="#OpenLDAP-的-ACL（访问控制列表）" class="headerlink" title="OpenLDAP 的 ACL（访问控制列表）"></a>OpenLDAP 的 ACL（访问控制列表）</h1><p>OpenLDAP 中的访问控制列表 (ACL) 是一套强大的规则，用于定义谁 (who) 可以对目录中的哪些数据 (what) 执行何种操作 (access level)。正确配置 ACL 是保护 LDAP 目录安全、确保数据完整性和实现细粒度权限管理的关键。</p><p>OpenLDAP 的 ACL 规则遵循一个基本结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access to &lt;what&gt;</span><br><span class="line">    [by &lt;who&gt; &lt;access_level&gt; [&lt;control&gt;]]+</span><br></pre></td></tr></table></figure><p>或者在动态配置 <code>cn=config</code> 中（推荐方式），使用 <code>olcAccess</code> 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">olcAccess: &#123;&lt;index&gt;&#125;to &lt;what&gt;</span><br><span class="line">  [by &lt;who&gt; &lt;access_level&gt; [&lt;control&gt;]]</span><br><span class="line">  [by &lt;who&gt; &lt;access_level&gt; [&lt;control&gt;]]</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>&#123;&lt;index&gt;&#125;</code>: 是一个非负整数，用于对多条 <code>olcAccess</code> 规则进行排序。规则按索引号从小到大评估。</li><li><code>to &lt;what&gt;</code>: 定义规则适用的目标资源（条目或属性）。</li><li><code>by &lt;who&gt; &lt;access_level&gt; [&lt;control&gt;]</code>: 定义授权子句。一个 <code>access to</code> 块可以包含多个 <code>by</code> 子句。</li></ul><h2 id="ACL-加载顺序"><a href="#ACL-加载顺序" class="headerlink" title="ACL 加载顺序"></a>ACL 加载顺序</h2><ul><li>OpenLDAP 服务器会按照 olcAccess 规则的索引顺序（或 slapd.conf 中的顺序）逐个评估 access to 块。当请求的目标与某个 access to 块的 <what> 部分匹配时，服务器会继续在该块内部按顺序评估 by <who> 子句。通常，该块内第一个匹配的 by <who> 子句所授予的权限会生效，除非使用了 continue 或 break 等控制流指令。</li><li>设计 ACL 规则时，强烈建议遵循“从最具体到最通用”的排序原则。例如，先为特定条目或属性定义规则，然后是子树，最后是全局规则。在 by <who> 子句内部也应遵循此原则。</li><li>如果请求的操作没有匹配任何 access to 块，或者在匹配的块内没有 by <who> 子句授予权限，并且没有配置非限制性的 olcDefaultAccess，则访问将被拒绝。为确保明确的默认拒绝策略，最佳实践是在 ACL 规则集的末尾添加一条 access to * by * none 规则。</li></ul><h2 id="ACL-语法详解"><a href="#ACL-语法详解" class="headerlink" title="ACL 语法详解"></a>ACL 语法详解</h2><ol><li><code>to &lt;what&gt;</code> (目标资源)</li></ol><p>这部分指定 ACL 规则应用于目录中的哪些对象或属性。</p><ul><li><code>*</code>: 应用于所有条目和属性。</li><li><code>dn[.&lt;style&gt;]=&lt;pattern&gt;</code>: 应用于 DN (Distinguished Name) 匹配的条目。<ul><li>Pattern: DN 字符串或正则表达式。<br>例如: <code>dn.subtree=&quot;ou=users,dc=example,dc=com&quot;</code></li><li>Style:<ul><li><code>base</code> (或 <code>exact</code>): 精确匹配 DN。<br><code>to dn.exact=&quot;ou=users,dc=example,dc=com&quot;</code></li><li><code>one</code> (或 <code>onelevel</code>): 匹配指定 DN 的下一级子条目。<br><code>to dn.one=&quot;ou=groups,dc=example,dc=com&quot;</code></li><li><code>subtree</code>: 匹配指定 DN 及其所有子树条目。<br><code>to dn.subtree=&quot;dc=example,dc=com&quot;</code></li><li><code>children</code>: 匹配指定 DN 的所有子树条目，但不包括该 DN 本身。</li><li><code>regex</code>: 使用正则表达式匹配 DN。<br><code>to dn.regex=&quot;uid=[^,]+,ou=users,dc=example,dc=com&quot;</code></li></ul></li></ul></li><li><code>attrs=&lt;attrlist&gt;</code>: 应用于条目中的特定属性。<ul><li><code>attrlist</code>: 逗号分隔的属性名列表 (e.g., <code>userPassword,mail</code>) 或特殊值：<ul><li><code>entry</code>: 条目本身（控制添加、删除、重命名等操作），不包括其属性。</li><li><code>children</code>: 条目的子条目（控制添加、删除子条目）。<br><code>to attrs=userPassword,shadowLastChange</code><br><code>to attrs=entry</code></li></ul></li></ul></li><li><code>filter=&lt;ldap_filter&gt;</code>: 应用于匹配 LDAP 搜索过滤器的条目。<br><code>to filter=&quot;(objectClass=inetOrgPerson)&quot;</code></li><li><code>val.&lt;attribute&gt;=&lt;value&gt;</code>: (较少用) 应用于其 <code>&lt;attribute&gt;</code> 属性具有特定 <code>&lt;value&gt;</code> 的条目。</li></ul><ol start="2"><li><code>by &lt;who&gt;</code> (访问者)</li></ol><p>指定谁可以执行操作。</p><ul><li><code>*</code>: 任何人，包括匿名用户。<br><code>by * read</code></li><li><code>anonymous</code>: 未认证的（匿名）用户。<br><code>by anonymous auth</code></li><li><code>users</code>: 任何已成功认证的用户。<br><code>by users read</code></li><li><code>self</code>: 正在访问的条目与当前绑定用户的 DN 相同。<br>这是实现用户修改自己信息（如密码）的关键。<br><code>by self write</code></li><li><code>dn[.&lt;style&gt;]=&lt;pattern&gt;</code>: 特定 DN 或匹配模式的 DN。<br>Style: <code>base</code> (或 <code>exact</code>), <code>regex</code>, <code>subtree</code> (表示绑定用户是该子树下的用户)。<br><code>by dn.exact=&quot;cn=admin,dc=example,dc=com&quot; manage</code></li><li><code>group[/&lt;objectclass&gt;[/&lt;groupattr&gt;]][.&lt;style&gt;]=&lt;pattern&gt;</code>: 属于特定组的成员。<ul><li><code>objectclass</code>: 组对象的 objectClass (e.g., <code>groupOfNames</code>, <code>groupOfUniqueNames</code>)。<br>默认为 <code>groupOfNames</code>。</li><li><code>groupattr</code>: 包含组成员 DN 的属性 (e.g., <code>member</code>, <code>uniqueMember</code>)。<br>默认为 <code>member</code>。</li><li>Style and Pattern: 用于匹配组的 DN。<br><code>by group.exact=&quot;cn=administrators,ou=groups,dc=example,dc=com&quot; write</code></li></ul></li><li><code>peername.&lt;style&gt;=&lt;pattern&gt;</code>: 基于客户端的 IP 地址或主机名。<br><code>by peername.ip=&quot;192.168.1.0/24&quot; read</code></li><li><code>sockname.&lt;style&gt;=&lt;pattern&gt;</code>: 基于服务器监听的 IP 地址。</li><li><code>dnattr=&lt;attrname&gt;</code>: 绑定用户的 DN 存在于目标条目的某个指定属性中<br>（例如，条目的 <code>owner</code> 属性值是当前用户的 DN）。<br><code>by dnattr=owner write</code></li><li><code>set=&lt;set_expression&gt;</code>: 使用布尔逻辑 (<code>AND</code>, <code>OR</code>, <code>NOT</code>, <code>&amp;</code>, <code>|</code>, <code>!</code>) 组合多个 <code>&lt;who&gt;</code> 条件。<br><code>by set=&quot;user and group/groupOfNames/member.exact=cn=editors,ou=groups,dc=example,dc=com&quot; write</code><br>或者更简洁的语法 (OpenLDAP 2.5+):<code>by set=&quot;[cn=editors,ou=groups,dc=example,dc=com]/member &amp; user&quot; write</code></li></ul><ol start="3"><li><code>&lt;access_level&gt;</code> (权限级别)</li></ol><p>指定授予的权限。权限是分级的，较高的权限通常隐含较低的权限。</p><ul><li><code>none</code>: 无任何访问权限。</li><li><code>disclose</code>: 允许在访问被拒绝时报告更详细的原因 (不常用)。</li><li><code>auth</code>: 认证权限 (允许用户使用该条目进行 BIND 操作，例如检查密码)。</li><li><code>compare</code>: 比较权限 (允许执行 LDAP 比较操作)。</li><li><code>search</code>: 搜索权限 (允许在搜索操作中返回此条目&#x2F;属性，隐含 <code>compare</code> 权限)。</li><li><code>read</code>: 读取权限 (允许读取条目&#x2F;属性的值，隐含 <code>search</code> 和 <code>compare</code> 权限)。</li><li><code>write</code>: 写入权限 (允许修改、添加、删除属性；也允许 <code>add</code>, <code>delete</code>, <code>modrdn</code> 操作，如果应用到 <code>entry</code> 或 <code>children</code>。隐含 <code>read</code>, <code>search</code>, <code>compare</code> 权限)。</li><li><code>manage</code>: 管理权限 (OpenLDAP 2.5+)。这是一个更高级别的权限，通常授予对子条目、模式等的管理能力。隐含 <code>write</code>。</li></ul><ol start="4"><li><code>&lt;control&gt;</code> (控制流)</li></ol><p>可选，控制 ACL 处理流程。</p><ul><li><code>stop</code>: 如果此 <code>by</code> 子句匹配，则停止处理当前 <code>access to</code> 块中的后续 <code>by</code> 子句。这是默认行为。</li><li><code>continue</code>: 如果此 <code>by</code> 子句匹配，则授予指定的权限，并继续处理当前 <code>access to</code> 块中的后续 <code>by</code> 子句。这允许权限累积或被后续规则覆盖。</li><li><code>break</code>: 如果此 <code>by</code> 子句匹配，则停止处理所有后续的 <code>access to</code> 块。</li><li><code>implicit</code>: (OpenLDAP 2.5+) 使其行为如同由 <code>olcDefaultAccess</code> 定义的默认访问权限。</li><li><code>self &lt;access_level&gt;</code>: 类似于 <code>by self &lt;access_level&gt;</code>，但通常用于特定场景，例如结合 <code>set</code>。</li></ul><p><strong>例子</strong></p><p>一个用于hdb的支持用户自行修改密码的 ACL，注意目前正常普遍是mdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dn: olcDatabase=&#123;2&#125;hdb,cn=config</span><br><span class="line">changetype: modify</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: &#123;0&#125;to attrs=userPassword</span><br><span class="line">  by self write</span><br><span class="line">  by anonymous auth</span><br><span class="line">  by * none</span><br><span class="line">-</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: &#123;1&#125;to attrs=shadowLastChange by self write by * read</span><br><span class="line">-</span><br><span class="line">add: olcAccess</span><br><span class="line">olcAccess: &#123;2&#125;to * by * read</span><br></pre></td></tr></table></figure><p>其它简单示例 (olcAccess 格式):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># &#123;0&#125; Allow rootdn full access (this is usually implicit but can be explicit)</span><br><span class="line">olcAccess: &#123;0&#125;to *</span><br><span class="line">  by dn.exact=&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth&quot; manage</span><br><span class="line">  by dn.exact=&quot;cn=admin,dc=example,dc=com&quot; manage</span><br><span class="line">  by * break</span><br><span class="line"></span><br><span class="line"># &#123;1&#125; Users can read their own entry and change their own password</span><br><span class="line">olcAccess: &#123;1&#125;to dn.subtree=&quot;ou=users,dc=example,dc=com&quot;</span><br><span class="line">  by self write_protect=&quot;userPassword&quot; # Example of attribute-level write protection</span><br><span class="line">  by self read</span><br><span class="line">  by group.exact=&quot;cn=helpdesk,ou=groups,dc=example,dc=com&quot; write # Helpdesk can manage users</span><br><span class="line">  by * auth</span><br><span class="line"></span><br><span class="line"># &#123;2&#125; Users can read common attributes in other user entries</span><br><span class="line">olcAccess: &#123;2&#125;to dn.subtree=&quot;ou=users,dc=example,dc=com&quot;</span><br><span class="line">  attrs=&quot;uid,cn,sn,givenName,mail,telephoneNumber&quot;</span><br><span class="line">  by users read</span><br><span class="line">  by anonymous auth # Allow anonymous bind to check if user exists for some apps</span><br><span class="line"></span><br><span class="line"># &#123;3&#125; Allow users to read group information</span><br><span class="line">olcAccess: &#123;3&#125;to dn.subtree=&quot;ou=groups,dc=example,dc=com&quot;</span><br><span class="line">  by users read</span><br><span class="line">  by anonymous auth</span><br><span class="line"></span><br><span class="line"># &#123;4&#125; Deny everything else to everyone else by default</span><br><span class="line"># This is very important!</span><br><span class="line">olcAccess: &#123;4&#125;to *</span><br><span class="line">  by * none</span><br><span class="line">Use code with caution.</span><br></pre></td></tr></table></figure><p>注意： 上面的 write_protect&#x3D;&quot;userPassword&quot; 不是标准的OpenLDAP ACL语法，它更像是一个概念性描述。正确的做法是，针对 userPassword 单独设置规则，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Users can change their own password</span><br><span class="line">olcAccess: &#123;X&#125;to dn.subtree=&quot;ou=users,dc=example,dc=com&quot;</span><br><span class="line">  attrs=userPassword</span><br><span class="line">  by self write</span><br><span class="line">  by group.exact=&quot;cn=helpdesk,ou=groups,dc=example,dc=com&quot; write</span><br><span class="line">  by anonymous auth # For password changes, often need auth for old pass</span><br><span class="line">  by * none</span><br><span class="line"></span><br><span class="line"># Users can read their other attributes (excluding password)</span><br><span class="line">olcAccess: &#123;Y&#125;to dn.subtree=&quot;ou=users,dc=example,dc=com&quot;</span><br><span class="line">  filter=(objectClass=inetOrgPerson) # Example filter</span><br><span class="line">  attrs!=&quot;userPassword&quot; # Exclude password from general read</span><br><span class="line">  by self read</span><br><span class="line">  by users read # If users should read other users&#x27; info</span><br><span class="line">  by * none</span><br></pre></td></tr></table></figure><h1 id="OpenLDAP-权限验证"><a href="#OpenLDAP-权限验证" class="headerlink" title="OpenLDAP 权限验证"></a>OpenLDAP 权限验证</h1><p><code>-Y EXTERNAL -H ldapi:///</code>  本地 root 权限绑定，仅限ldapserver本地使用，也就是要在docker内执行命令(权限级别与使用rootdn一样)</p><p>EXTERNAL 是一种 SASL（Simple Authentication and Security Layer）机制，用于通过已有的外部身份验证方式（例如 Unix socket 权限）来认证你的 LDAP 操作。</p><p>SASL 是一种认证框架，OpenLDAP 支持多种 SASL 机制，例如：</p><ul><li>PLAIN</li><li>DIGEST-MD5</li><li>GSSAPI</li><li>EXTERNAL</li></ul><p>EXTERNAL 是其中一种最常见的机制，通常用于本地系统用户以 root 权限访问 OpenLDAP 的配置数据库（cn&#x3D;config），不需要输入用户名和密码。</p><p>当你通过 EXTERNAL 使用 Unix socket 登录时，OpenLDAP 会通过 socket 的所有者判断是谁发起的连接，比如：</p><ul><li>如果你是 root 用户，就会映射为 gidNumber&#x3D;0+uidNumber&#x3D;0,cn&#x3D;peercred,cn&#x3D;external,cn&#x3D;auth。</li><li>通常系统会在 olcAccess 中授予该身份读写权限。</li></ul><h1 id="LDAP-集成"><a href="#LDAP-集成" class="headerlink" title="LDAP 集成"></a>LDAP 集成</h1><p>主要有两种配置，一个是对 AD 的集成，还有一个则是对 OpenLDAP 的集成。</p><p>需要注意的是，AD 虽然底层也符合标准，但跟 OpenLDAP 的各项属性有很大区别，很多服务会特别的专门适配 AD，但有些会以 OpenLDAP 为标准，连接 AD 会需要自行修改配置项。</p><h2 id="OS-集成"><a href="#OS-集成" class="headerlink" title="OS 集成"></a>OS 集成</h2><h3 id="SSSD-或-NSCD"><a href="#SSSD-或-NSCD" class="headerlink" title="SSSD 或 NSCD"></a>SSSD 或 NSCD</h3><p>sssd 会更现代一些，不过强制 ldaps，安全以及复杂。如果各种 ssl 苦手且目标环境做了物理隔离，建议 nscd。(不过 sssd 战未来)，请务必注意 NSCD 会跟现代的 systemd-resolved 的缓存机制产生冲突和不可预知的行为。遇到问题可能需要<code>sudo nscd -i hosts</code> 清理一下</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>debian 是有一个 ldapd，<a href="https://wiki.debian.org/LDAP/PAM">https://wiki.debian.org/LDAP/PAM</a> </p><p>ubuntu 也有 ldapd，但是没有存在感， ubuntu 所有的教程还是基于非 ldapd 的，甚至 AI 都不知道有这个包。</p><h3 id="集成配置"><a href="#集成配置" class="headerlink" title="集成配置"></a>集成配置</h3><p>deb 系是 sudo pam-auth-update，rpm 系是有 &#39;&#39;authconfig --enableldap --enableldapauth&#39;&#39;。后者看 redhat 文档就好</p><h2 id="bindn"><a href="#bindn" class="headerlink" title="bindn"></a>bindn</h2><p>通常 AD 下使用具有域控管理员权限的账号，不过出于安全性考虑可以降低权限（普通 domain user 没有读取其他用户邮箱的权限），目前都使用的管理员权限的账号做bind</p><p>OpenLDAP 中则一般使用 rootdn (也可以不使用，不过需要创建具有特殊权限的账号)</p><h2 id="Base-DN"><a href="#Base-DN" class="headerlink" title="Base DN"></a>Base DN</h2><p>定义：LDAP 搜索操作（例如 ldapsearch）使用的“起始 DN”，决定了查询范围的顶端节点。</p><p>格式：通常为域组件（DC，Domain Component），如 dc&#x3D;example,dc&#x3D;com；也可为组织单元（OU，如 ou&#x3D;Users,dc&#x3D;example,dc&#x3D;com）或通用名称（CN，如 cn&#x3D;Administrator,cn&#x3D;Users,dc&#x3D;example,dc&#x3D;com）。 </p><p><strong>在客户端或应用配置中填入 Base DN 后，后续的搜索操作会从该节点及其子树进行。例如，若 Base DN 为 ou&#x3D;Users,dc&#x3D;example,dc&#x3D;com，那么只有位于该 OU 下的用户才会被索引。</strong></p><p>上面加粗了，因为实际上大多会使用 Users 或 People ,主要是查找用户</p><p>不过你需要注意下有些服务是不需要同步 LDAP 组的，例如 dokuwiki 里就没有设basedn，他会让你设用户过滤和组的过滤条件。</p><h2 id="LDAP-过滤器"><a href="#LDAP-过滤器" class="headerlink" title="LDAP 过滤器"></a>LDAP 过滤器</h2><p>LDAP 过滤器 (LDAP Filter) 在与 LDAP&#x2F;AD 集成的应用程序（如 DokuWiki 的 authad 插件 或 Snipe-IT）中扮演着至关重要的角色。它定义了<strong>如何查找和验证用户</strong>。</p><p>简单来说，LDAP 过滤器就像是你在 Active Directory 这个大数据库里进行搜索时使用的<strong>搜索条件</strong>。你需要告诉应用程序：当用户尝试登录时，应该使用哪些标准来找到 AD 中对应的用户对象，并确认这个对象是有效的、允许登录的。</p><p>一个可供参考的问题见 <a href="https://github.com/witersen/SvnAdminV2.0/issues/51">Issue</a></p><h3 id="LDAP-过滤器的基本语法"><a href="#LDAP-过滤器的基本语法" class="headerlink" title="LDAP 过滤器的基本语法"></a>LDAP 过滤器的基本语法</h3><ul><li>使用括号 <code>()</code> 包裹整个过滤器。</li><li>基本条件通常是 <code>(属性名=值)</code> 的形式。</li><li>可以使用逻辑运算符将多个条件组合起来：<br>*   <strong>&amp;</strong>：与 (AND) - 所有条件都必须满足。格式：<code>(&amp;(条件1)(条件2)...)</code><br>*   <strong>|</strong>：或 (OR) - 至少一个条件满足。格式：<code>(|(条件1)(条件2)...)</code><br>*   <strong>!</strong>：非 (NOT) - 条件不满足。格式：<code>(!(条件))</code></li><li>值可以是具体的值，也可以是通配符 <code>*</code>，或者是一个<strong>占位符</strong>，应用程序会在运行时将其替换为用户输入的内容（通常是用户名）。</li></ul><h3 id="常用的-AD-用户属性及过滤器构建块"><a href="#常用的-AD-用户属性及过滤器构建块" class="headerlink" title="常用的 AD 用户属性及过滤器构建块"></a>常用的 AD 用户属性及过滤器构建块</h3><ul><li><code>objectCategory=person</code>：查找对象类别为 &quot;person&quot; 的对象（通常包含用户）。</li><li><code>objectClass=user</code>：查找对象类别为 &quot;user&quot; 的对象。通常与 <code>objectCategory=person</code> 一起使用，更精确地定位用户。</li><li><code>sAMAccountName</code>：用户的登录名（通常是 Windows 2000 之前的短名称，例如 <code>johndoe</code>）。这是最常用的登录名字段。</li><li><code>userPrincipalName</code> (UPN)：用户的邮箱风格登录名（例如 <code>johndoe@yourdomain.local</code>）。</li><li><code>mail</code>：用户的电子邮件地址。有时也用作登录名。</li><li><code>userAccountControl</code>：一个包含用户账户状态（如是否禁用）的位掩码。查找<strong>未禁用</strong>的用户通常使用位操作符： <code>(!(userAccountControl:1.2.840.113556.1.4.803:=2))</code>。这里的 <code>2</code> 代表 <code>ADS_UF_ACCOUNTDISABLE</code> 标志位，<code>:1.2.840.113556.1.4.803:=</code> 是进行位与 (Bitwise AND) 比较的 LDAP 匹配规则。整个表达式的意思是“userAccountControl 属性中没有设置值为 2 的那个位”。</li><li><code>memberOf</code>：用于检查用户是否属于某个特定的组。值需要是组的完整 <strong>Distinguished Name (DN)</strong>，例如 <code>CN=AppUsers,OU=Groups,DC=yourdomain,DC=local</code>。</li></ul><h3 id="常见的-LDAP-用户过滤器示例"><a href="#常见的-LDAP-用户过滤器示例" class="headerlink" title="常见的 LDAP 用户过滤器示例"></a>常见的 LDAP 用户过滤器示例</h3><p><strong>注意：</strong> 以下示例使用占位符 <code>&#123;username&#125;</code> 代表用户输入的用户名。<strong>请务必查阅你所使用的应用程序（如 DokuWiki authad 插件）的文档，确认它实际使用的占位符是什么</strong>，可能是 <code>@USER@</code>, <code>%user%</code>, <code>$user</code> 等。</p><p>最基本：使用 sAMAccountName 查找未禁用的用户 (推荐作为起点) </p><p>下面最外层的括号或许需要取消</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;(objectCategory=person)(objectClass=user)(sAMAccountName=&#123;username&#125;)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))</span><br></pre></td></tr></table></figure><ul><li><code>&amp;</code>: 所有条件都需满足。</li><li><code>objectCategory=person</code> 和 <code>objectClass=user</code>: 确保找到的是用户对象。</li><li><code>sAMAccountName=&#123;username&#125;</code>: 用户的 <code>sAMAccountName</code> 属性必须等于登录时输入的用户名。</li><li><code>(!(userAccountControl:1.2.840.113556.1.4.803:=2))</code>: 确保账户未被禁用。(部分服务会同步已禁用账号，然后在本地显示账号禁用，如果不需要可以直接通过过滤器排除掉)</li></ul><p><strong>OpenLDAP</strong><br>因为大部分都会以 OpenLDAP 为主，所以基本没什么好写的，你只要注意不要因为自己设的不同名字的 OU 被坑了就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;(objectClass=posixGroup)(|(memberUid=%&#123;uid&#125;)(gidNumber=%&#123;gid&#125;)))</span><br></pre></td></tr></table></figure><ul><li><code>objectCategory=posixGroup</code>: 确保找到的是组对象。</li><li><code>|(memberUid=%&#123;uid&#125;)(gidNumber=%&#123;gid&#125;)</code>: 用户主组是gidNumber，memberUid是次组</li></ul><h3 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h3><p>最新的 OpanLDAP 通常使用动态配置</p><p>bitnami 的 openldap 中获取信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slapcat -F /bitnami/openldap/slapd.d/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LDAP[轻型目录访问协议](Lightweight Directory Access Protocol)(属于X.500) 是一种目录服务(Directory service)标准。&lt;/p&gt;
&lt;p&gt;目录是一个特殊的数据库，它的数据经常被查询，但是不经常更新。不像普通的数据</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="开源(Open Source)" scheme="http://ted423.github.io/tags/%E5%BC%80%E6%BA%90-Open-Source/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="AD(Active Directory)" scheme="http://ted423.github.io/tags/AD-Active-Directory/"/>
    
  </entry>
  
  <entry>
    <title>特殊文件关联</title>
    <link href="http://ted423.github.io/Document/%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94/"/>
    <id>http://ted423.github.io/Document/%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94/</id>
    <published>2025-05-09T08:49:27.342Z</published>
    <updated>2025-05-09T08:56:18.116Z</updated>
    
    <content type="html"><![CDATA[<p>最早是被 <a href="/Software/Document&Texteditor/Everedit">Everedit</a> 坑的</p><p>总之这类文件关联位置如下，可以参考找一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\batfile\shell\open\command</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最早是被 &lt;a href=&quot;/Software/Document&amp;Texteditor/Everedit&quot;&gt;Everedit&lt;/a&gt; 坑的&lt;/p&gt;
&lt;p&gt;总之这类文件关联位置如下，可以参考找一下&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="Regedit" scheme="http://ted423.github.io/tags/Regedit/"/>
    
  </entry>
  
  <entry>
    <title>邮件客户端选型</title>
    <link href="http://ted423.github.io/Software/Mail/"/>
    <id>http://ted423.github.io/Software/Mail/</id>
    <published>2025-05-09T02:13:58.639Z</published>
    <updated>2025-05-09T03:25:40.087Z</updated>
    
    <content type="html"><![CDATA[<p>目前还是在用 Foxmail，主要是没有太多的可选性</p><h1 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h1><p>这是一个收费客户端</p><h1 id="Thunderbird"><a href="#Thunderbird" class="headerlink" title="Thunderbird"></a>Thunderbird</h1><p>过滤器有 Bug，也就是明明符合规则但是不生效。</p><h1 id="Betterbird"><a href="#Betterbird" class="headerlink" title="Betterbird"></a>Betterbird</h1><p>就软件的开发愿景来说是很好的，可惜最新版连中文语言包都不提供了。</p><h1 id="SeaMonkey"><a href="#SeaMonkey" class="headerlink" title="SeaMonkey"></a>SeaMonkey</h1><p>定位错误的一个软件，包含浏览器并且界面很丑。我可以接受浏览器里带邮件客户端，但不能接受这么丑的界面。</p><h1 id="Claws-Mail"><a href="#Claws-Mail" class="headerlink" title="Claws Mail"></a>Claws Mail</h1><p>没中文 界面也相当老</p><h1 id="Mailspring"><a href="#Mailspring" class="headerlink" title="Mailspring"></a>Mailspring</h1><p>不支持 pop3 <a href="https://github.com/Foundry376/Mailspring/issues/45">https://github.com/Foundry376/Mailspring/issues/45</a></p><p>整体来说我觉得这个看法相当的 Stupid，pop3保留副本仍然是相当重要的。特别是大部分的服务商都是有限容量的邮箱。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前还是在用 Foxmail，主要是没有太多的可选性&lt;/p&gt;
&lt;h1 id=&quot;Outlook&quot;&gt;&lt;a href=&quot;#Outlook&quot; class=&quot;headerlink&quot; title=&quot;Outlook&quot;&gt;&lt;/a&gt;Outlook&lt;/h1&gt;&lt;p&gt;这是一个收费客户端&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="分类汇总" scheme="http://ted423.github.io/tags/%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/"/>
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="开源(Open Source)" scheme="http://ted423.github.io/tags/%E5%BC%80%E6%BA%90-Open-Source/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
  </entry>
  
  <entry>
    <title>迷思，记录下我为什么不用 EverythingToolbar</title>
    <link href="http://ted423.github.io/Software/EverythingToolbar/"/>
    <id>http://ted423.github.io/Software/EverythingToolbar/</id>
    <published>2025-05-01T02:41:33.431Z</published>
    <updated>2025-07-10T02:24:33.398Z</updated>
    
    <content type="html"><![CDATA[<p>我挺喜欢 Everything 的，当时一看这个立马就装了，结果就尴尬了。</p><ol><li>结果没法保存，操作失误或者打开文件位置之后还要重新搜索，实际体验不如我直接在 Everything 里搜索。</li><li>开软件等搜索很喜欢先按Win键，用 EverythingToolbar 反而需要我鼠标点过去，这个跟直接使用 Everything 并没有直接区别。反而还有第一点的负面。</li></ol><p>本着软件尽量少装的原则就卸掉了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我挺喜欢 Everything 的，当时一看这个立马就装了，结果就尴尬了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结果没法保存，操作失误或者打开文件位置之后还要重新搜索，实际体验不如我直接在 Everything 里搜索。&lt;/li&gt;
&lt;li&gt;开软件等搜索很喜欢先按Win键，用 Ever</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="MIT" scheme="http://ted423.github.io/tags/MIT/"/>
    
    <category term="开源(Open Source)" scheme="http://ted423.github.io/tags/%E5%BC%80%E6%BA%90-Open-Source/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="defect" scheme="http://ted423.github.io/tags/defect/"/>
    
  </entry>
  
  <entry>
    <title>[Terminal]Bat 脚本中的变量延迟扩展 (Delayed Expansion)</title>
    <link href="http://ted423.github.io/Code/Terminal/bat_Delayed_Expansion/"/>
    <id>http://ted423.github.io/Code/Terminal/bat_Delayed_Expansion/</id>
    <published>2025-04-24T02:57:43.212Z</published>
    <updated>2025-04-24T03:26:00.308Z</updated>
    
    <content type="html"><![CDATA[<p>在 Bat 脚本中，变量的默认扩展方式是即时扩展 (Immediate Expansion)。这意味着，当 Bat 解释器解析一个命令行或一个代码块（用括号 () 括起来的一组命令）时，它会立即用变量的当前值替换所有用百分号<code>%</code>括起来的变量引用（例如<code>%str%</code>）。</p><p>问题出现在当你需要在同一个代码块内部修改一个变量，并且希望在该代码块内部的后续命令中立即使用这个修改后的新值时。由于即时扩展是在代码块开始执行之前进行的，整个块在解析时会使用变量的旧值，而不是你在块内部更新后的值。</p><p>为了解决这个问题，Bat 提供了变量延迟扩展。启用延迟扩展后，你可以使用感叹号<code>!</code>来引用变量（例如<code>!str!</code>）。当 Bat 解释器执行到一个使用<code>!var!</code>的命令时，它会当时去获取变量 var 的最新值。</p><p>一般可能比较难理解，我遇到的就是 if 里面 for 循环赋值输出不正确。需要用<code>!str!</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Bat 脚本中，变量的默认扩展方式是即时扩展 (Immediate Expansion)。这意味着，当 Bat 解释器解析一个命令行或一个代码块（用括号 () 括起来的一组命令）时，它会立即用变量的当前值替换所有用百分号&lt;code&gt;%&lt;/code&gt;括起来的变量引用（例如</summary>
      
    
    
    
    <category term="Code" scheme="http://ted423.github.io/categories/Code/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Code" scheme="http://ted423.github.io/tags/Code/"/>
    
    <category term="CMD" scheme="http://ted423.github.io/tags/CMD/"/>
    
    <category term="Terminal" scheme="http://ted423.github.io/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>打印机自定义纸张大小注意事项</title>
    <link href="http://ted423.github.io/Hardware/printer/"/>
    <id>http://ted423.github.io/Hardware/printer/</id>
    <published>2025-04-14T13:29:46.617Z</published>
    <updated>2025-04-16T14:45:28.620Z</updated>
    
    <content type="html"><![CDATA[<p>最近主要是添加凭据打印纸之后发现别人的电脑可以选，我自己电脑死活显示不出打印选项。</p><p>具体可能跟驱动版本还有些关系，另一方面，就是惠普打印机只支持宽度小于21.59厘米，而打印服务器里我把宽设的24cm，这里是个坑注意下就好了。</p><p>可以设140mm x 240mm。因为纸是竖着放的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近主要是添加凭据打印纸之后发现别人的电脑可以选，我自己电脑死活显示不出打印选项。&lt;/p&gt;
&lt;p&gt;具体可能跟驱动版本还有些关系，另一方面，就是惠普打印机只支持宽度小于21.59厘米，而打印服务器里我把宽设的24cm，这里是个坑注意下就好了。&lt;/p&gt;
&lt;p&gt;可以设140mm </summary>
      
    
    
    
    <category term="Hardware" scheme="http://ted423.github.io/categories/Hardware/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="Hardware" scheme="http://ted423.github.io/tags/Hardware/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
    <category term="Driver&amp;Firmware" scheme="http://ted423.github.io/tags/Driver-Firmware/"/>
    
  </entry>
  
  <entry>
    <title>LXC 为什么不火</title>
    <link href="http://ted423.github.io/Linux/LXC/"/>
    <id>http://ted423.github.io/Linux/LXC/</id>
    <published>2025-04-08T08:33:19.064Z</published>
    <updated>2025-04-08T08:39:21.572Z</updated>
    
    <content type="html"><![CDATA[<p>LXC容器共享主机的内核，这意味着容器必须运行与主机相同或兼容的内核版本。这一点非常重要，因为它直接影响到容器中可以运行的操作系统类型。</p><p>其实光靠上面这段就够了。前有 KVM，后有 docker,LXC 这种尴尬处境，那肯定火不起来</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LXC容器共享主机的内核，这意味着容器必须运行与主机相同或兼容的内核版本。这一点非常重要，因为它直接影响到容器中可以运行的操作系统类型。&lt;/p&gt;
&lt;p&gt;其实光靠上面这段就够了。前有 KVM，后有 docker,LXC 这种尴尬处境，那肯定火不起来&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="开源(Open Source)" scheme="http://ted423.github.io/tags/%E5%BC%80%E6%BA%90-Open-Source/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="defect" scheme="http://ted423.github.io/tags/defect/"/>
    
    <category term="Command" scheme="http://ted423.github.io/tags/Command/"/>
    
  </entry>
  
  <entry>
    <title>记一次试图逃离 MobaXterm</title>
    <link href="http://ted423.github.io/Software/tryoutMobaXterm/"/>
    <id>http://ted423.github.io/Software/tryoutMobaXterm/</id>
    <published>2025-04-07T12:05:48.320Z</published>
    <updated>2025-04-07T12:21:37.231Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/Software/MobaXterm">MobaXterm</a> 毕竟现在用的破解，所以如果能不用或者如果有能替代的方案我是很开心的。</p><p>可以看到我之前尝试过一次。</p><p>这回是看到微软新的那个终端非常有想法，故就准备全部切换过去。</p><p>为此还折腾了<a href="/Software/X11">X11</a>。快速连接就靠终端的配置来弄，然后全部使用 sshkey,弄好可能还会变得高端。</p><p>可惜最后被 MobaXterm 自动显示服务器资源情况的功能给击沉了。这种功能基本就只有商业软件会做了吧。或者国产开源之类的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/Software/MobaXterm&quot;&gt;MobaXterm&lt;/a&gt; 毕竟现在用的破解，所以如果能不用或者如果有能替代的方案我是很开心的。&lt;/p&gt;
&lt;p&gt;可以看到我之前尝试过一次。&lt;/p&gt;
&lt;p&gt;这回是看到微软新的那个终端非常有想法，故就准备全部切换过去。</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="Terminal" scheme="http://ted423.github.io/tags/Terminal/"/>
    
    <category term="破解&amp;激活" scheme="http://ted423.github.io/tags/%E7%A0%B4%E8%A7%A3-%E6%BF%80%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>tmux 使用</title>
    <link href="http://ted423.github.io/Linux/tmux/"/>
    <id>http://ted423.github.io/Linux/tmux/</id>
    <published>2025-04-07T07:06:17.249Z</published>
    <updated>2025-04-07T08:14:15.348Z</updated>
    
    <content type="html"><![CDATA[<p>tmux（Terminal Multiplexer）是一款 终端复用工具，允许在单一终端窗口中创建、管理和切换多个 会话、窗口 和 面板，支持终端会话的持久化与灵活分屏。</p><p>开源协议是 ISC许可证</p><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><ul><li>远程工作时，防止因网络中断导致任务终止。</li><li>高效管理多任务并行环境（如开发、运维、日志监控）。</li><li>替代传统终端，实现类 IDE 的多窗口协作体验。</li></ul><h1 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h1><p>开启使用命令 <code>tmux</code></p><p>列出会话 <code>tmux ls</code></p><p>重连会话 <code>tmux attach -t 0</code></p><p>翻页&#x2F;滚动操作 按<code>ctrl+b</code>后按<code>[</code></p><p>复制 按住<code>shift</code></p><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><table><thead><tr><th>操作</th><th>命令&#x2F;快捷键</th></tr></thead><tbody><tr><td>新建会话</td><td>tmux new -s &lt;会话名&gt;</td></tr><tr><td>分离当前会话</td><td>Ctrl+b → d</td></tr><tr><td>列出会话</td><td>tmux ls</td></tr><tr><td>重连会话</td><td>tmux attach -t &lt;会话名&gt;</td></tr><tr><td>关闭会话</td><td>tmux kill-session -t &lt;会话名&gt;</td></tr><tr><td>重命名会话</td><td>Ctrl+b → $</td></tr></tbody></table><h2 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h2><table><thead><tr><th>操作</th><th>快捷键（Ctrl+b 后按）</th></tr></thead><tbody><tr><td>新建窗口</td><td>c</td></tr><tr><td>关闭窗口</td><td>&amp;</td></tr><tr><td>切换窗口</td><td>0-9 或 n（下一窗口）&#x2F;p（上一窗口）</td></tr><tr><td>重命名窗口</td><td>,</td></tr><tr><td>窗口列表</td><td>w</td></tr></tbody></table><h2 id="面板管理"><a href="#面板管理" class="headerlink" title="面板管理"></a>面板管理</h2><table><thead><tr><th>操作</th><th>快捷键（Ctrl+b 后按）</th></tr></thead><tbody><tr><td>垂直分割面板</td><td>%</td></tr><tr><td>水平分割面板</td><td>&quot;</td></tr><tr><td>切换面板</td><td>方向键（←↑↓→）</td></tr><tr><td>关闭面板</td><td>x</td></tr><tr><td>调整面板大小</td><td>Ctrl+方向键</td></tr><tr><td>切换布局</td><td>空格</td></tr></tbody></table><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>tmux 默认行数上限 2000，应该是性能和内存考虑，不过10万行大概也才几十MiB内存</p><p>全局配置文件 <code>/etc/tmux.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set -g history-limit 100000</span><br><span class="line">set -g mouse on #启用鼠标滚屏</span><br></pre></td></tr></table></figure><p>注意版本，因为老版，例如 CentOS7 用的 mode-mouse</p><p>通常建议是使用个人配置 <code>~/.tmux.conf</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tmux（Terminal Multiplexer）是一款 终端复用工具，允许在单一终端窗口中创建、管理和切换多个 会话、窗口 和 面板，支持终端会话的持久化与灵活分屏。&lt;/p&gt;
&lt;p&gt;开源协议是 ISC许可证&lt;/p&gt;
&lt;h1 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; c</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="开源(Open Source)" scheme="http://ted423.github.io/tags/%E5%BC%80%E6%BA%90-Open-Source/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="Command" scheme="http://ted423.github.io/tags/Command/"/>
    
  </entry>
  
  <entry>
    <title>git 换行符问题</title>
    <link href="http://ted423.github.io/Code/Git/git%20eol/"/>
    <id>http://ted423.github.io/Code/Git/git%20eol/</id>
    <published>2025-04-06T09:54:42.615Z</published>
    <updated>2025-07-13T13:09:52.725Z</updated>
    
    <content type="html"><![CDATA[<p>之前被坑过一次，py 文件上传到 Github 后下回来全部用不了，最后发现是因为换行符的问题。（这个现在想来可能是二进制文件没正常识别导致的，实际解决问题的可能是<code>text=auto</code>）<br>默认上传都是自动改成 Linux(LF) 上传，下下来就还是 LF，Win 上面就全炸了。</p><p><del>默认行为core.autocrlf&#x3D;input</del> 目前查看(<code>git config --list</code>)是 <code>core.autocrlf=true</code>。但有文章说默认是<code>false</code>，该环境应该是Linux，可能 <code>Github-desktop</code> 的有所不同，如果 Windows 先装 git 可能也不一样。</p><p>行为说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false 对换行符不做任何修改</span><br><span class="line">True  上传为 lf，git 检出自动替换为 crlf，需要提醒，不确定检出时替换会不会因为文件后缀问题失效，因为部分文件可能不会被识别为 text</span><br><span class="line">input 上传为 lf，检出不做改动，可以避免将 crlf 提交到数据库</span><br></pre></td></tr></table></figure><p><del>一般这种不建议改全局设置，除非你的全部项目都是只有自己一个人维护，</del>实际上我个人是全局关 autocrlf</p><p>团队最好统一配置。可以在项目的 .gitattributes 里改。</p><p><del>一般也不会设置 autocrlf 的值，而是直接固定项目文件的换行符</del></p><p>目前我是自己设了 <code>autocrlf=false</code>，因为我实在受不了预判和&quot;帮你做决定&quot;</p><p><code>text=auto</code>意味着会自动判断，例如一些图片不会被设置文本属性。(之前未设置的时候有遇到exe被设置了text属性)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* text=auto</span><br><span class="line">* eol=crlf</span><br></pre></td></tr></table></figure><p>更具体的还有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*           text=auto</span><br><span class="line">*.txttext</span><br><span class="line">*.vcprojtext eol=crlf</span><br><span class="line">*.shtext eol=lf</span><br><span class="line">*.jpg-text</span><br></pre></td></tr></table></figure><p><code>-text</code>意味着去除文本属性</p><p>今天想起来，顺便给 Hexo 里弄了下，这样每次跑不会一大堆 warning，不过设的是 lf</p><p>参考</p><ul><li><a href="https://stackoverflow.com/questions/42667996/enforce-core-autocrlf-input-through-gitattributes">https://stackoverflow.com/questions/42667996/enforce-core-autocrlf-input-through-gitattributes</a></li><li><a href="https://git-scm.com/docs/gitattributes">https://git-scm.com/docs/gitattributes</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前被坑过一次，py 文件上传到 Github 后下回来全部用不了，最后发现是因为换行符的问题。（这个现在想来可能是二进制文件没正常识别导致的，实际解决问题的可能是&lt;code&gt;text=auto&lt;/code&gt;）&lt;br&gt;默认上传都是自动改成 Linux(LF) 上传，下下来就</summary>
      
    
    
    
    <category term="Code" scheme="http://ted423.github.io/categories/Code/"/>
    
    
    <category term="Github" scheme="http://ted423.github.io/tags/Github/"/>
    
    <category term="Code" scheme="http://ted423.github.io/tags/Code/"/>
    
    <category term="Git" scheme="http://ted423.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>VSCode</title>
    <link href="http://ted423.github.io/Software/Document&amp;Texteditor/VSCode/"/>
    <id>http://ted423.github.io/Software/Document&amp;Texteditor/VSCode/</id>
    <published>2025-04-02T15:55:36.669Z</published>
    <updated>2025-04-07T03:52:53.907Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.visualstudio.com/">https://code.visualstudio.com</a></p><p><a href="https://github.com/microsoft/vscode">https://github.com/microsoft/vscode</a></p><p>需要注意它的安装包分为 User 和全局的，全局的要管理员权限安装。普通用户用 User 的就好</p><p>VSCode 是我非常想用但又用的非常蛋疼的一个软件</p><p>问题有</p><ul><li>经常帮你记住一堆文件，打开弹出乱七八糟的东西(到现在还没完全解决)</li><li>设置项一堆，然后网页搜索经常搜到过时的东西</li><li>中文全都给你弄个框框框住(非基本 ASCII 字符 设置)</li><li>开久了卡死，就一个标签在那，明显哪里存在这内存泄漏之类的问题。<del>(最后发现是 Ditto 的问题)</del>(并不)</li><li>信任文件夹之后，子文件夹打开的文件仍然提示不受信任<br>(AI告诉我：如果用户直接打开子文件夹（例如通过文件资源管理器或命令行），VS Code 可能将其视为独立工作区，而不是父文件夹的一部分，从而触发初始信任提示。官方文档建议始终通过父文件夹打开，以确保继承信任。)<br>我最终把工作区信任整个给关了。可能 VSCode 是把信任工作区和信任文件夹给分开的。开启的话，新打开的窗口默认就算不受信任的工作区。</li></ul><p>配置项</p><p>Hot Exit<br>应该是上面那个造成帮你记住一堆文件的 <strong>其中</strong> 一个配置(并且似乎关闭了也偶尔会生效)，并且有时候一开给你开两个退出前的窗口</p><p>我觉得它的设置项过于复杂到 SB 的程度了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;https://code.visualstudio.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/vscode&quot;&gt;https://g</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="MIT" scheme="http://ted423.github.io/tags/MIT/"/>
    
    <category term="开源(Open Source)" scheme="http://ted423.github.io/tags/%E5%BC%80%E6%BA%90-Open-Source/"/>
    
    <category term="Document&amp;Texteditor" scheme="http://ted423.github.io/tags/Document-Texteditor/"/>
    
  </entry>
  
  <entry>
    <title>Wintel 的大小核问题处理</title>
    <link href="http://ted423.github.io/Hardware/%E5%A4%A7%E5%B0%8F%E6%A0%B8/"/>
    <id>http://ted423.github.io/Hardware/%E5%A4%A7%E5%B0%8F%E6%A0%B8/</id>
    <published>2025-03-17T13:19:29.774Z</published>
    <updated>2025-03-16T13:03:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>咋说呢，毕竟 Intel 不太行了，有一个解决方案其实是 AMD YES!</p><p>但架不住，AMD 的品牌机真没几个牌子做，所以 Intel 现在的状态我是真不太理解。</p><p>现在的设计真傻逼，后台就降 cpu 占用。跑编译的估计都在那骂娘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">powercfg -attributes SUB_PROCESSOR 7f2f5cfa-f10c-4823-b5e1-e93ae85f46b5 -ATTRIB_HIDE</span><br><span class="line">powercfg -attributes SUB_PROCESSOR 93b8b6dc-0698-4d1c-9ee4-0644e900c85d -ATTRIB_HIDE</span><br><span class="line">powercfg -attributes SUB_PROCESSOR bae08b81-2d5e-4688-ad6a-13243356654b -ATTRIB_HIDE</span><br><span class="line">powercfg -attributes SUB_PROCESSOR b28a6829-c5f7-444e-8f61-10e24e85c532 -ATTRIB_HIDE</span><br></pre></td></tr></table></figure><p>然后在电源管理的高级那里改就好了</p><p>资料来源<br><a href="https://www.chiphell.com/thread-2524998-1-1.html">https://www.chiphell.com/thread-2524998-1-1.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;咋说呢，毕竟 Intel 不太行了，有一个解决方案其实是 AMD YES!&lt;/p&gt;
&lt;p&gt;但架不住，AMD 的品牌机真没几个牌子做，所以 Intel 现在的状态我是真不太理解。&lt;/p&gt;
&lt;p&gt;现在的设计真傻逼，后台就降 cpu 占用。跑编译的估计都在那骂娘。&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    <category term="Hardware" scheme="http://ted423.github.io/categories/Hardware/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="Hardware" scheme="http://ted423.github.io/tags/Hardware/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
    <category term="Regedit" scheme="http://ted423.github.io/tags/Regedit/"/>
    
  </entry>
  
</feed>
