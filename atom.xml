<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人小站</title>
  
  <subtitle>Take&amp;Give</subtitle>
  <link href="http://ted423.github.io/atom.xml" rel="self"/>
  
  <link href="http://ted423.github.io/"/>
  <updated>2026-02-14T15:36:51.448Z</updated>
  <id>http://ted423.github.io/</id>
  
  <author>
    <name>ted423</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[问题处理]可能是新式待机状态造成的问题</title>
    <link href="http://ted423.github.io/Issue/%E6%96%B0%E5%BC%8F%E5%BE%85%E6%9C%BA%E7%8A%B6%E6%80%81/"/>
    <id>http://ted423.github.io/Issue/%E6%96%B0%E5%BC%8F%E5%BE%85%E6%9C%BA%E7%8A%B6%E6%80%81/</id>
    <published>2026-02-14T14:34:56.009Z</published>
    <updated>2026-02-14T15:36:51.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h1><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/design/device-experiences/modern-standby-states">https://learn.microsoft.com/zh-cn/windows-hardware/design/device-experiences/modern-standby-states</a></p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><ol><li>目前笔记本默认都是 S0(Modern Standby)，也叫低电量待机，大多数新笔记本默认都不支持传统的 S3 模式了。<code>powercfg /a</code> 可查</li><li>台式机看起来都支持，不过在系统配置中，支持 S0，就会默认禁用 S3。</li><li>我手动直接关闭了 S0:<code>reg add &quot;HKLM\System\CurrentControlSet\Control\Power&quot; /v PlatformAoAcOverride /t REG_DWORD /d 0 /f</code></li></ol><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>笔记本合上盖子，在部分情况下，无法重新开机，开机后完全电源键闪几下后完全全新启动。</p><p>尝试关闭睡眠，设置不进入睡眠，开启休眠都无效。</p><p>日志里可以看到电脑进入 S0。</p><p>按前面的彻底关闭 S0 (由于笔记本不支持 S3)，导致睡眠完全消失，作为替代，只使用休眠。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>实际上笔记本睡眠后起不来是一个长期以来的问题，同型号，同硬件，有的有有的没有。从 Win7 时代就开始了。</p><p>只是目前没法判断是硬件问题还是微软的锅。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;官方解释&quot;&gt;&lt;a href=&quot;#官方解释&quot; class=&quot;headerlink&quot; title=&quot;官方解释&quot;&gt;&lt;/a&gt;官方解释&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/zh-cn/windows-hardware/de</summary>
      
    
    
    
    <category term="Issue" scheme="http://ted423.github.io/categories/Issue/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
  </entry>
  
  <entry>
    <title>[问题处理]Powershell7的右键菜单奇怪行为</title>
    <link href="http://ted423.github.io/Issue/pwsh/"/>
    <id>http://ted423.github.io/Issue/pwsh/</id>
    <published>2026-02-04T08:45:39.023Z</published>
    <updated>2026-02-04T08:58:22.021Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.ps1</span><br></pre></td></tr></table></figure><p>下面的 UserChoice 删掉</p><p>选择 Vscode 打开会不显示，默认打开是记事本的话会显示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="Issue" scheme="http://ted423.github.io/categories/Issue/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
    <category term="Windows Server" scheme="http://ted423.github.io/tags/Windows-Server/"/>
    
    <category term="傻逼微软" scheme="http://ted423.github.io/tags/%E5%82%BB%E9%80%BC%E5%BE%AE%E8%BD%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Git]设置查看和取消代理</title>
    <link href="http://ted423.github.io/Code/Git/git%20proxy/"/>
    <id>http://ted423.github.io/Code/Git/git%20proxy/</id>
    <published>2026-01-26T05:54:25.956Z</published>
    <updated>2026-01-23T12:27:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:7890</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --get http.proxy</span><br></pre></td></tr></table></figure><p>吐槽下git的升级连续用了3个裸IP</p><p>https那个没用</p><hr><p>似乎可能Win下cmd里用就是会解析成IP丢到代理里(</p><h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>另外需要注意，git 协议走 ssh,需要 ssh 代理以及 ssh key</p><p>Github Desktop 对 ssh key 的支持并不好，它的官方教程让设置 passphrase,因此每次使用都要输入，但它自己的客户端不支持并且会每次都报错 -<time datetime=2025-01-08>2025-01-08</time></p><p>下面是 Win 的配置,config 文件需要自己新建出来，key 的话，放在那里不用特意写配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ProxyCommand connect -S 127.0.0.1:7890 -a none %h %p</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 22</span><br><span class="line">  Hostname github.com</span><br><span class="line">  TCPKeepAlive yes</span><br><span class="line"></span><br><span class="line">Host ssh.github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 443</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  TCPKeepAlive yes</span><br></pre></td></tr></table></figure><h1 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h1><p>注意哈，这里没有写错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -c http.proxy=socks5h://127.0.0.1:13222 &lt;url&gt;</span><br></pre></td></tr></table></figure><p>另外注意是<code>-c</code>是全局的，其他命令要直接放在<code>git</code>后面</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    <category term="Git" scheme="http://ted423.github.io/categories/Git/"/>
    
    
    <category term="Proxy" scheme="http://ted423.github.io/tags/Proxy/"/>
    
    <category term="Git" scheme="http://ted423.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Container Storage Interface (CSI)</title>
    <link href="http://ted423.github.io/Document/CSI/"/>
    <id>http://ted423.github.io/Document/CSI/</id>
    <published>2026-01-20T13:18:12.162Z</published>
    <updated>2026-01-20T14:20:49.720Z</updated>
    
    <content type="html"><![CDATA[<p>Container Storage Interface (CSI) 用来建立一个标准的、通用的存储接口，使得存储供应商（SP）只需要编写一次插件，就可以在所有支持 CSI 的容器编排系统中使用。</p><p>CSI 是目前 Kubernetes 和其他容器编排系统（如 Mesos, Docker Swarm）推荐和事实上的标准接口，用于实现存储的动态供给。</p><h1 id="内联-In-tree-卷插件"><a href="#内联-In-tree-卷插件" class="headerlink" title="内联 (In-tree) 卷插件"></a>内联 (In-tree) 卷插件</h1><p>这些插件是 Kubernetes 核心代码的一部分，例如 <code>awsElasticBlockStore</code>、<code>gcePersistentDisk</code>、<code>azureDisk</code>、<code>cephfs</code>、<code>nfs</code>、<code>iscsi</code> 等。</p><ul><li><strong>动态供给机制</strong>: 当用户创建一个 <code>PVC</code> 并引用一个支持动态供给的 <code>StorageClass</code> 时，Kubernetes 的 <code>kube-controller-manager</code> 会调用对应的内联卷插件去创建后端存储资源。</li><li><strong>缺点</strong>:<ul><li>与 Kubernetes 核心代码紧密耦合，新存储功能的开发和发布需要与 Kubernetes 版本同步。</li><li>如果一个存储供应商要支持 Kubernetes，他们必须将自己的代码贡献到 Kubernetes 核心仓库中，这增加了门槛和维护成本。</li><li>更新驱动需要升级整个 Kubernetes 集群。</li></ul></li></ul><h1 id="CSI-Container-Storage-Interface"><a href="#CSI-Container-Storage-Interface" class="headerlink" title="CSI (Container Storage Interface)"></a>CSI (Container Storage Interface)</h1><p>k8s 里通过 helm 部署</p><p>CSI 就是为了解决内联插件的这些问题而诞生的。它提供了一个<strong>标准接口</strong>，将存储插件的开发从 Kubernetes 核心中剥离出来。</p><ul><li><strong>动态供给机制</strong>: 当用户创建 <code>PVC</code> 和 <code>StorageClass</code> 时，Kubernetes 会调用 CSI 驱动的 <code>CreateVolume</code> RPC 方法去创建后端存储资源。</li><li><strong>优点</strong>:<ul><li><strong>解耦</strong>: 存储插件可以独立于 Kubernetes 发布和更新。</li><li><strong>扩展性</strong>: 任何存储供应商都可以基于 CSI 规范开发自己的驱动，无需修改 Kubernetes 核心代码。</li><li><strong>灵活性</strong>: 新功能（如快照、扩容）可以更快地实现和迭代。</li></ul></li></ul><h1 id="动态供给-Dynamic-Provisioning"><a href="#动态供给-Dynamic-Provisioning" class="headerlink" title="动态供给 (Dynamic Provisioning)"></a>动态供给 (Dynamic Provisioning)</h1><p>动态供给允许存储卷按需创建。系统根据用户的 PVC 请求，自动在存储端创建物理卷，并自动生成对应的 PV 对象。先有请求，后有卷。</p><p>动态供给通常只能生成机器生成的、具有唯一性的名字（通常包含 UUID），用户无法完全自定义后端存储的卷名。</p><h1 id="静态供给-Static-Provisioning"><a href="#静态供给-Static-Provisioning" class="headerlink" title="静态供给 (Static Provisioning)"></a>静态供给 (Static Provisioning)</h1><p>预先在存储端创建好物理卷，并手动在 Kubernetes 中创建对应的 PV 对象。先有卷，后有请求。管理员手动创建 PV<br>PVC，并手动写配置文件进行挂载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Container Storage Interface (CSI) 用来建立一个标准的、通用的存储接口，使得存储供应商（SP）只需要编写一次插件，就可以在所有支持 CSI 的容器编排系统中使用。&lt;/p&gt;
&lt;p&gt;CSI 是目前 Kubernetes 和其他容器编排系统（如 M</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="k8s(Kubernetes)" scheme="http://ted423.github.io/tags/k8s-Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>iSCSI 简要笔记</title>
    <link href="http://ted423.github.io/Document/iSCSI/"/>
    <id>http://ted423.github.io/Document/iSCSI/</id>
    <published>2026-01-10T14:46:18.495Z</published>
    <updated>2026-01-10T14:54:22.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="名词说明"><a href="#名词说明" class="headerlink" title="名词说明"></a>名词说明</h1><p>SCSI (Small Computer System Interface，小型计算机系统接口) 是一种用于计算机及其外围设备（如硬盘、磁带驱动器、扫描仪等）之间进行数据传输的协议标准和命令集。它定义了一套标准的命令（称为 SCSI 命令集）、协议（如何交换这些命令和数据）以及电气和光学接口。</p><p>iSCSI (Internet Small Computer System Interface) 是一种存储网络协议。它的核心功能是将 SCSI 命令封装在 TCP&#x2F;IP 数据包中，并通过标准的以太网进行传输。本质上，iSCSI 允许两台主机通过 IP 网络交换 SCSI 命令，从而实现块级存储的远程访问，就像设备是本地连接的一样。</p><p>iSCSI 的架构是 C&#x2F;S 架构（客户端&#x2F;服务器）</p><p>initiator (发起端)</p><p>Target (目标端)是 iSCSI 协议架构中的服务端端点 (Server Endpoint)。</p><p>LUN (逻辑单元号)</p><p>LUN（逻辑单元） 与 Target（目标） 之间的内部映射关系（LUN Mapping）。</p><p>一个 Target 可以包含（映射）多个 LUN (LUN 0, LUN 1, ...)。</p><h2 id="LUN-Logical-Unit-Number"><a href="#LUN-Logical-Unit-Number" class="headerlink" title="LUN (Logical Unit Number)"></a>LUN (Logical Unit Number)</h2><p>LUN 逻辑单元 (Logical Unit, LU) 是一个通过 SCSI 协议标准进行寻址的块存储设备。</p><p>LUN 是存储网络环境中，从物理存储资源中抽象出来的、可被服务器独立寻址和使用的块存储单元的数字标识符。</p><p>LUN 可以由截然不同的技术和对象构成。</p><ul><li>直接物理设备映射 (Direct Physical Device Mapping)</li><li>逻辑卷映射 (Logical Volume Mapping)</li><li>文件映射 (File-based Mapping)</li><li>专用卷映射 (Specialized Volume Mapping)  ZFS ZVOL (ZFS Volume) 或 Btrfs 上的类似对象。</li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Target 是存储设备上运行的一个逻辑实体，负责监听 TCP&#x2F;IP 端口（默认 3260），接收并解析来自 Initiator（客户端，即 K8s 节点）的 SCSI 指令。</p><p>每个 Target 都有一个全球唯一的标识符，称为 IQN (iSCSI Qualified Name)。initiator 通过 IQN 唯一定位要连接的目标。</p><p>权限控制通常在 Target 级别进行配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;名词说明&quot;&gt;&lt;a href=&quot;#名词说明&quot; class=&quot;headerlink&quot; title=&quot;名词说明&quot;&gt;&lt;/a&gt;名词说明&lt;/h1&gt;&lt;p&gt;SCSI (Small Computer System Interface，小型计算机系统接口) 是一种用于计算机及其外围设</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
  </entry>
  
  <entry>
    <title>Github-Destop 下 Gist 的 commit 问题</title>
    <link href="http://ted423.github.io/Code/Git/gist/"/>
    <id>http://ted423.github.io/Code/Git/gist/</id>
    <published>2026-01-07T02:50:16.391Z</published>
    <updated>2026-01-07T03:17:53.702Z</updated>
    
    <content type="html"><![CDATA[<p>Github 似乎没想做 Github-Desktop 跟 Gist 的集成。对于 Gist 来说，Github-Desktop 跟普通的客户端一样，push 会需要单独登录，需要使用 token。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Github 似乎没想做 Github-Desktop 跟 Gist 的集成。对于 Gist 来说，Github-Desktop 跟普通的客户端一样，push 会需要单独登录，需要使用 token。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Git" scheme="http://ted423.github.io/categories/Git/"/>
    
    
    <category term="Github" scheme="http://ted423.github.io/tags/Github/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
    <category term="Git" scheme="http://ted423.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Windows RSAT(Remote Server Administration Tools) 远程服务器管理工具</title>
    <link href="http://ted423.github.io/Document/Acrive%20Directry/RAST/"/>
    <id>http://ted423.github.io/Document/Acrive%20Directry/RAST/</id>
    <published>2026-01-05T03:06:38.617Z</published>
    <updated>2026-01-05T03:54:38.170Z</updated>
    
    <content type="html"><![CDATA[<p>Win 上可以装 Openssh Server，之前试了可以连进去。不过 Win 原生有远程的一些命令可以使用，通常没必要使用 ssh。</p><p>以下所有说明基于标准的域环境。</p><p>RSAT 主要涉及到使用 IPC (进程间通信) Inter-Process Communication</p><p>IPC$ (Inter-Process Communication)：这是 Windows 的一个隐藏共享，专门用于进程间通信。</p><h1 id="RPC-SMB"><a href="#RPC-SMB" class="headerlink" title="RPC&#x2F;SMB"></a>RPC&#x2F;SMB</h1><p>RPC 是老协议，但是域控到普通机子仍然一直在走 RPC</p><p>远程过程调用。它是 Windows NT 时代就存在的基石技术。它的核心思想是：让在一台电脑上运行的程序，能够像调用本地函数一样，去调用另一台电脑上的函数。</p><p>走 RPC (Remote Procedure Call) &#x2F; SMB 的命令：</p><ul><li><code>quser</code> &#x2F; <code>qwinsta</code>（查询用户）</li><li><code>logoff</code>（注销用户）</li><li><code>sc</code>（服务控制）</li><li><code>services.msc</code>（远程连接服务控制台）</li><li><code>PsExec</code>（虽然它利用 SMB 管道，但本质依赖 RPC&#x2F;DCOM 机制）</li></ul><p>注意 SMB 是 RPC 的“载体”，也负责 组策略 (Group Policy) 的分发。</p><p>示例命令（远程注销用户登录，用于桌面卡死，无法远程）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qwinsta /server:&lt;pcname&gt;</span><br><span class="line"> 会话名               用户名                 ID  状态   类型        设备</span><br><span class="line"> services                                            0  断开</span><br><span class="line"> console                                             3  已连接</span><br><span class="line"> rdp-tcp#0                xx              4  运行中</span><br><span class="line"> rdp-tcp                                         65536  侦听</span><br><span class="line"></span><br><span class="line">logoff 4  /server:&lt;pcname&gt;</span><br></pre></td></tr></table></figure><h1 id="WinRM"><a href="#WinRM" class="headerlink" title="WinRM"></a>WinRM</h1><p>Windows 远程管理。它是微软对 WS-Management 协议的实现。这是一种基于 Web 标准（SOAP&#x2F;XML）的协议。</p><p>WinRM 并不是为了完全替代 RPC 而生的，它只是为了“替代 RPC 在远程管理领域的角色”。(协议开销更大，历史包袱与生态)</p><p>WinRM 只使用两个端口: TCP 5985 (HTTP), TCP 5986 (HTTPS)</p><p>虽然默认端口叫 HTTP，但在域环境中，WinRM 的 Payload（负载数据）是经过 Kerberos 密钥加密的。它不是明文传输。</p><p>如果需要更高安全性（如通过互联网管理），可以配置 SSL 证书开启 HTTPS。</p><p>WinRM 可以通过配置（JEA - Just Enough Administration）限制远程用户只能运行特定的几条命令，而 RPC 这种控制很难实现。</p><p>走 WinRM (Windows Remote Management) 的命令：</p><ul><li><code>Invoke-Command</code></li><li><code>Enter-PSSession</code></li><li>所有带 <code>-ComputerName</code> 参数且非 WMI&#x2F;DCOM 实现的 PowerShell Cmdlet。</li></ul><p>示例命令(重启服务)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Command -ComputerName &lt;pcname&gt; -ScriptBlock &#123; Restart-Service TermService -Force &#125;</span><br></pre></td></tr></table></figure><p>在 CMD 时代，微软专门提供了一个基于 WinRM 协议的命令行工具，叫做 winrs (Windows Remote Shell)。但是因为返回值以及其他一些功能深度上的问题，一般还是建议 Powershell</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Win 上可以装 Openssh Server，之前试了可以连进去。不过 Win 原生有远程的一些命令可以使用，通常没必要使用 ssh。&lt;/p&gt;
&lt;p&gt;以下所有说明基于标准的域环境。&lt;/p&gt;
&lt;p&gt;RSAT 主要涉及到使用 IPC (进程间通信) Inter-Process</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="AD(Active Directory)" scheme="http://ted423.github.io/tags/AD-Active-Directory/"/>
    
  </entry>
  
  <entry>
    <title>WSL</title>
    <link href="http://ted423.github.io/Software/WSL/"/>
    <id>http://ted423.github.io/Software/WSL/</id>
    <published>2025-12-31T12:29:15.270Z</published>
    <updated>2025-12-31T11:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WSL-Windows-Subsystem-for-Linux"><a href="#WSL-Windows-Subsystem-for-Linux" class="headerlink" title="WSL (Windows Subsystem for Linux)"></a>WSL (Windows Subsystem for Linux)</h1><p>WSL 是微软推出的兼容层工具，允许用户在 Windows 系统上原生运行 Linux 二进制文件，无需传统虚拟机或双系统。</p><h2 id="核心优势"><a href="#核心优势" class="headerlink" title="核心优势"></a>核心优势</h2><p>无缝的 Windows 与 Linux 集成</p><h3 id="文件系统互操作性"><a href="#文件系统互操作性" class="headerlink" title="文件系统互操作性"></a>文件系统互操作性</h3><ul><li><strong>在 Linux 中访问 Windows 文件</strong>：<br>自动挂载在 <code>/mnt</code> 下。例如，访问 C 盘用户目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/c/Users/YourName</span><br></pre></td></tr></table></figure></li><li><strong>在 Windows 中访问 Linux 文件</strong>：<br>在资源管理器地址栏输入以下路径（其中 <code>&lt;发行版名称&gt;</code> 需替换为实际名称，如 <code>Ubuntu-22.04</code>）：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\wsl$\&lt;发行版名称&gt;\</span><br></pre></td></tr></table></figure></li><li><strong>典型用例</strong>：<br>开发者可以直接使用 Windows 端的 IDE（如 VS Code）编辑位于 Linux 环境中的代码文件。</li></ul><h3 id="命令行混合调用"><a href="#命令行混合调用" class="headerlink" title="命令行混合调用"></a>命令行混合调用</h3><ul><li><strong>在 PowerShell 或 CMD 中运行 Linux 命令</strong>：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="built_in">ls</span> <span class="literal">-l</span> /home  <span class="comment"># 调用 Linux 的 `ls` 命令</span></span><br></pre></td></tr></table></figure></li><li><strong>在 Linux 中运行 Windows 程序</strong>：<br>可以直接调用 <code>.exe</code>，例如 <code>explorer.exe .</code>。</li></ul><hr><h2 id="安装与初始化"><a href="#安装与初始化" class="headerlink" title="安装与初始化"></a>安装与初始化</h2><p>在管理员模式下的 PowerShell 或 CMD 中执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化安装（默认安装 Ubuntu）</span></span><br><span class="line">wsl.exe <span class="literal">--install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出可在线安装的发行版列表</span></span><br><span class="line">wsl <span class="literal">--list</span> <span class="literal">--online</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定的发行版</span></span><br><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;发行版名称&gt;</span><br><span class="line"><span class="comment"># 示例：wsl --install -d Ubuntu-22.04</span></span><br></pre></td></tr></table></figure><hr><h2 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h2><h3 id="管理发行版"><a href="#管理发行版" class="headerlink" title="管理发行版"></a>管理发行版</h3><table><thead><tr><th align="left">功能</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left"><strong>列出所有发行版</strong></td><td align="left"><code>wsl -l -v</code></td></tr><tr><td align="left"><strong>设置默认发行版</strong></td><td align="left"><code>wsl --set-default &lt;名称&gt;</code></td></tr><tr><td align="left"><strong>直接运行命令</strong></td><td align="left"><code>wsl &lt;命令&gt;</code> (如 <code>wsl ls /</code>)</td></tr><tr><td align="left"><strong>版本更新</strong></td><td align="left"><code>wsl --update</code></td></tr></tbody></table><h3 id="备份与迁移-导入-导出"><a href="#备份与迁移-导入-导出" class="headerlink" title="备份与迁移 (导入&#x2F;导出)"></a>备份与迁移 (导入&#x2F;导出)</h3><p><strong>导出（备份）</strong>：<br>将现有系统打包成 tar 文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--export</span> &lt;名称&gt; &lt;备份文件名&gt;.tar</span><br><span class="line"><span class="comment"># 示例：wsl --export Ubuntu-22.04 backup.tar</span></span><br></pre></td></tr></table></figure><p><strong>导入（恢复&#x2F;迁移）</strong>：<br>将备份文件导入为新的发行版。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--import</span> &lt;新名称&gt; &lt;安装路径&gt; &lt;备份文件名&gt;.tar</span><br><span class="line"><span class="comment"># 示例：wsl --import Ubuntu-New D:\WSL\Ubuntu backup.tar</span></span><br></pre></td></tr></table></figure><p><strong>⚠️ 注意事项</strong>：</p><ol><li><strong>删除需谨慎</strong>：使用 <code>wsl --unregister &lt;名称&gt;</code> 会注销发行版并<strong>永久删除</strong>其对应的虚拟磁盘文件（ext4.vhdx），请务必先备份。</li><li><strong>迁移建议</strong>：<ul><li><strong>推荐</strong>：使用官方的 <code>export</code> 和 <code>import</code> 流程，这能最大程度避免跨机器兼容性问题。</li><li><strong>本机迁移</strong>：如果是本机移动位置，也可以先关闭 WSL，手动移动 <code>.vhdx</code> 硬盘文件，然后 <code>unregister</code> 原系统，再在新位置执行 <code>import</code>（指向移动后的文件）。</li><li><strong>注册表修改（不推荐）</strong>：WSL 注册信息存储在 <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Lxss</code>，理论上修改 <code>BasePath</code> 可行，但风险较大，不建议操作。</li></ul></li></ol><hr><h2 id="社区镜像与自定义安装"><a href="#社区镜像与自定义安装" class="headerlink" title="社区镜像与自定义安装"></a>社区镜像与自定义安装</h2><p>推荐直接使用在线安装。如果需要使用社区镜像（如 openSUSE），可以手动下载并导入。</p><h3 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h3><ul><li><strong>官方文档</strong>: <a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual">Microsoft Learn - WSL 安装手册</a></li><li><strong>官方 Ubuntu 22.04 镜像</strong>: <a href="https://aka.ms/wslubuntu2204">aka.ms&#x2F;wslubuntu2204</a></li><li><strong>社区镜像源 (openSUSE 等)</strong>: <a href="https://download.opensuse.org/repositories/Virtualization:/WSL:/instarball/">OpenSUSE Repository</a></li></ul><h3 id="手动导入示例"><a href="#手动导入示例" class="headerlink" title="手动导入示例"></a>手动导入示例</h3><p>假设镜像文件位于 <code>_images</code> 目录：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法：wsl --import &lt;系统名&gt; &lt;安装目录&gt; &lt;镜像tar包路径&gt;</span></span><br><span class="line">wsl <span class="literal">--import</span> openS<span class="built_in">USE-Leap</span><span class="literal">-15</span>.<span class="number">6</span> .\openS<span class="built_in">USE-Leap</span><span class="literal">-15</span>.<span class="number">6</span>\ .\openS<span class="built_in">USE-Leap</span><span class="literal">-15</span>.<span class="number">6</span><span class="literal">-15</span>.<span class="number">6</span>.x86_64.tar</span><br></pre></td></tr></table></figure><hr><h2 id="其他命令-Legacy-Global-Config"><a href="#其他命令-Legacy-Global-Config" class="headerlink" title="其他命令 (Legacy &#x2F; Global Config)"></a>其他命令 (Legacy &#x2F; Global Config)</h2><p><code>wslconfig</code> 是较旧但依然有效的全局配置工具：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前已安装系统（包含详细信息）</span></span><br><span class="line">wslconfig /l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换默认的系统</span></span><br><span class="line">wslconfig.exe /setdefault openS<span class="built_in">USE-Leap</span><span class="literal">-16</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WSL-Windows-Subsystem-for-Linux&quot;&gt;&lt;a href=&quot;#WSL-Windows-Subsystem-for-Linux&quot; class=&quot;headerlink&quot; title=&quot;WSL (Windows Subsystem for Lin</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="MIT" scheme="http://ted423.github.io/tags/MIT/"/>
    
    <category term="开源(Open Source)" scheme="http://ted423.github.io/tags/%E5%BC%80%E6%BA%90-Open-Source/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="System" scheme="http://ted423.github.io/tags/System/"/>
    
  </entry>
  
  <entry>
    <title>连不上的打印机会导致 Office 卡死</title>
    <link href="http://ted423.github.io/Issue/Office_Printer_Halt/"/>
    <id>http://ted423.github.io/Issue/Office_Printer_Halt/</id>
    <published>2025-12-18T06:15:03.948Z</published>
    <updated>2025-12-18T06:21:01.296Z</updated>
    
    <content type="html"><![CDATA[<p>其实写这个就只想骂微软。</p><p>长期存在的问题，到现在都没解决。连不上你倒是给个提示啊，我又不打印。不知道什么脑抽回路还不修。</p><p>MDZZ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实写这个就只想骂微软。&lt;/p&gt;
&lt;p&gt;长期存在的问题，到现在都没解决。连不上你倒是给个提示啊，我又不打印。不知道什么脑抽回路还不修。&lt;/p&gt;
&lt;p&gt;MDZZ&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Issue" scheme="http://ted423.github.io/categories/Issue/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
  </entry>
  
  <entry>
    <title>开源文件清理工具 - BleachBit</title>
    <link href="http://ted423.github.io/%E5%9D%9F%E5%9C%BA/BleachBit/"/>
    <id>http://ted423.github.io/%E5%9D%9F%E5%9C%BA/BleachBit/</id>
    <published>2025-12-18T05:10:11.026Z</published>
    <updated>2026-01-08T10:17:04.029Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bleachbit.org/">https://www.bleachbit.org</a></p><p><a href="https://github.com/bleachbit/bleachbit">https://github.com/bleachbit/bleachbit</a></p><p>首先 CCleaner 是垃圾。</p><p>最近 cleanmgr 莫名其妙的 bug ,扫完清了，然后再打开是一点没清掉。</p><ul><li>这个软件支持自定义路径（<strong>加进去没法用可还行</strong>）</li><li>Linux 也支持，不过个人觉得不太需要（？），虽然 Linux 的软件比较喜欢随意路径拉屎。</li><li>深度扫描一般感觉不太需要使用，要用的也要注意这个扫描是严格扫描的后缀，我自己写的 .bak 也被扫出来了，真要有类似需求还是自定义路径吧。免得不小心干掉些可能要保留的东西</li><li>注意 系统 -&gt; 释放磁盘空闲区域 不要使用，这个是生成文件暴力填满硬盘空间。（感觉这个软件最好在界面里加点注释）</li><li>主要需求还是自定义路径，魔方也支持，但是似乎不能用通配符，并且它无了。</li><li>界面有点丑，界面交互过于简陋</li></ul><hr><p>界面看久了，眼睛直接不舒服了可还行，加上不太好的操作，没法自定义，直接送走。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bleachbit.org/&quot;&gt;https://www.bleachbit.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bleachbit/bleachbit&quot;&gt;https://github</summary>
      
    
    
    
    <category term="坟场" scheme="http://ted423.github.io/categories/%E5%9D%9F%E5%9C%BA/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="GPLv3" scheme="http://ted423.github.io/tags/GPLv3/"/>
    
    <category term="Maintenance" scheme="http://ted423.github.io/tags/Maintenance/"/>
    
  </entry>
  
  <entry>
    <title>Spy++ 查找全局快捷键冲突</title>
    <link href="http://ted423.github.io/Document/spy++/"/>
    <id>http://ted423.github.io/Document/spy++/</id>
    <published>2025-12-09T02:41:15.860Z</published>
    <updated>2025-12-09T02:48:13.134Z</updated>
    
    <content type="html"><![CDATA[<p>来源文章: <a href="https://zhuanlan.zhihu.com/p/704643938">https://zhuanlan.zhihu.com/p/704643938</a></p><p>Warning: 这个方法主要以开发手段来确认问题，比较复杂。</p><p>Spy++ 来源于 Visual Studio，社区版本也都包含。</p><p>安装后找到 spyxx_amd64.exe 并运行。该进程只会抓到同架构的程序的信息，所以理论如果有32位进程设了全局快捷键，只能用32位那个抓（未确认）。</p><ol><li>菜单栏 --&gt; 监视 --&gt; 日志消息，这样打开 消息选项 面板。</li><li>在 窗口 页签，点击 其他窗口 栏目下的 系统中的所有窗口。</li><li>切换到 消息 页签，点击 全部清除 按钮。勾一下 消息组 里面的 键盘。这样会自动在左侧 要查看的消息 里面选中一些项目，其中已经被选中的 WM_HOTKEY 是关键。然后确定。</li></ol><p>之后输入问题快捷键，然后看哪个进程有反应，我的情况是发现是 autolyrics, 就很 emmmm，也不好说作者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来源文章: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/704643938&quot;&gt;https://zhuanlan.zhihu.com/p/704643938&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Warning: 这个方法主要以开发手段来确认问题，比较复杂。&lt;</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
  </entry>
  
  <entry>
    <title>[问题处理]Docker Container 卡死关闭</title>
    <link href="http://ted423.github.io/Issue/stopContainer/"/>
    <id>http://ted423.github.io/Issue/stopContainer/</id>
    <published>2025-12-08T03:48:27.920Z</published>
    <updated>2025-12-08T07:11:25.384Z</updated>
    
    <content type="html"><![CDATA[<p>个人遇到的情况是宿主机挂载路径用了 fscache 导致的卡死，表现为 Cotainer 只要开启就会卡死，无法结束。</p><p>看到了 <a href="https://stackoverflow.com/questions/70434777/cannot-kill-container-container-id-tried-to-kill-container-but-did-not-rece">https://stackoverflow.com/questions/70434777/cannot-kill-container-container-id-tried-to-kill-container-but-did-not-rece</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw | grep $(docker container ls | grep &lt;containername&gt;  | awk &#x27;&#123;print $1&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>随后手动结束进程即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人遇到的情况是宿主机挂载路径用了 fscache 导致的卡死，表现为 Cotainer 只要开启就会卡死，无法结束。&lt;/p&gt;
&lt;p&gt;看到了 &lt;a href=&quot;https://stackoverflow.com/questions/70434777/cannot-kill-</summary>
      
    
    
    
    <category term="Issue" scheme="http://ted423.github.io/categories/Issue/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
  </entry>
  
  <entry>
    <title>K8S(Kubernetes) 笔记</title>
    <link href="http://ted423.github.io/Software/k8s/"/>
    <id>http://ted423.github.io/Software/k8s/</id>
    <published>2025-11-28T11:09:30.255Z</published>
    <updated>2026-02-08T15:24:26.014Z</updated>
    
    <content type="html"><![CDATA[<p>没空系统性整理，所以先记笔记好了</p><h1 id="最新版的Kubernetes-已不再使用-Docker"><a href="#最新版的Kubernetes-已不再使用-Docker" class="headerlink" title="最新版的Kubernetes 已不再使用 Docker"></a>最新版的Kubernetes 已不再使用 Docker</h1><p>Kubernetes v1.24+ 移除了 dockershim，不再直接依赖 Docker Engine 来作为容器运行时，并且推荐使用像 containerd 这样的 CRI 运行时。同时安装 Docker Engine 和独立的 containerd (被 Kubernetes 使用) 确实可能会导致一些混淆或潜在的冲突，但这并不意味着完全不能安装 Docker，或者某些教程推荐安装 Docker 就是完全错误的。<br>这里需要澄清几个关键点，解释为什么有些教程可能仍然会提到安装 docker.io (或 docker-ce)：<br>历史原因和习惯延续：<br>在 Kubernetes v1.23 及更早版本，Docker Engine 是最主流的容器运行时。大量的旧教程和很多人的经验都是基于 Docker 的。<br>即使 dockershim 被移除，Docker Engine 本身的核心运行时就是 containerd。所以，安装 Docker Engine 实际上也会安装和运行 containerd。<br>Docker CLI 的便利性：<br>很多人习惯使用 docker命令行工具 (docker ps, docker images, docker build 等) 来进行本地镜像构建、容器调试等操作。<br>即使 Kubernetes 使用独立的 containerd 实例，管理员或开发者可能仍然希望在节点上拥有 docker CLI 以便进行一些辅助操作。<br>crictl 是与 CRI 运行时（如 containerd）交互的标准工具，但其命令和用户体验与 docker CLI 不同，后者更为用户熟知。<br>误解或简化教程：<br>有些教程可能没有完全更新到最新的 Kubernetes 架构变化，或者为了简化步骤，直接让用户安装 Docker，因为 Docker 安装后，其内部的 containerd 可以被配置为 Kubernetes 的 CRI 运行时。<br>关键点在于如何配置 kubelet： 如果安装了 Docker Engine，kubelet 必须被配置为不使用已废弃的 dockershim，而是直接与 Docker Engine 内部的 containerd 的 CRI socket (&#x2F;run&#x2F;containerd&#x2F;containerd.sock，如果 Docker 将其暴露出来并与 Kubernetes 期望的一致) 通信。<br>Docker 仍然是构建镜像的主流工具：<br>虽然 Kubernetes 运行容器不直接依赖 Docker Engine，但构建容器镜像的生态系统仍然以 Dockerfile 和 docker build (或兼容工具如 buildah, kaniko) 为主。(可以看下最下面的命令)<br>因此，在开发环境或CI&#x2F;CD流程中，Docker Engine 仍然扮演重要角色。有些教程可能会将节点准备和镜像构建环境的准备步骤混合在一起。</p><h1 id="Helm-Helm-Charts"><a href="#Helm-Helm-Charts" class="headerlink" title="Helm &amp; Helm Charts"></a>Helm &amp; Helm Charts</h1><p>Helm 是 Kubernetes 的包管理器，目前唯一安装 Kubernetes Dashboard 的方式(然后它 Archive 了)，目前应该是推荐用<a href="https://github.com/kubernetes-sigs/headlamp">headlamp</a></p><p>Charts (Helm 包)： Helm 使用一种称为 &quot;Charts&quot; 的打包格式。一个 Chart 就是一个描述了一组相关 Kubernetes 资源的文件集合。它可以包含 Deployment, Service, ConfigMap, Secret, Ingress 等等，以及这些资源的配置模板。Charts 通常允许用户通过一个 values.yaml 文件或命令行参数来定制安装，而无需直接修改 Chart 的模板文件。Helm 会跟踪应用的版本，并允许你轻松地将应用回滚到之前的版本。</p><p>仓库 (Repositories)： Helm Charts 可以存储在称为 &quot;仓库&quot; 的地方，你可以添加这些仓库来访问社区或组织维护的 Charts。</p><h2 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h2><p>如 nfs-csi 的镜像代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install nfs-csi csi-driver-nfs/csi-driver-nfs --namespace kube-system \</span><br><span class="line">  --<span class="built_in">set</span> image.nfs.repository=docker.x.lan/k8s/sig-storage/nfsplugin \</span><br><span class="line">  --<span class="built_in">set</span> image.csiProvisioner.repository=docker.x.lan/k8s/sig-storage/csi-provisioner \</span><br><span class="line">  --<span class="built_in">set</span> image.livenessProbe.repository=docker.x.lan/k8s/sig-storage/livenessprobe \</span><br><span class="line">  --<span class="built_in">set</span> image.csiResizer.repository=docker.x.lan/k8s/sig-storage/csi-resizer \</span><br><span class="line">  --<span class="built_in">set</span> image.csiSnapshotter.repository=docker.x.lan/k8s/sig-storage/csi-snapshotter \</span><br><span class="line">  --<span class="built_in">set</span> image.csiNodeDriverRegistrar.repository=docker.x.lan/k8s/sig-storage/csi-node-driver-registrar</span><br></pre></td></tr></table></figure><p>打印官方提供的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm show values grafana/alloy</span><br></pre></td></tr></table></figure><h1 id="Master-移除以及清理"><a href="#Master-移除以及清理" class="headerlink" title="Master 移除以及清理"></a>Master 移除以及清理</h1><p><strong>注意事项</strong></p><ul><li>当需要调整 K8S Master 的时候，首要注意的 K8S 主节点之间是多数表决，一定要注意控制节点个数长期保持奇数，否则可能有集群不稳定以及脑裂（集群分裂成配置不同的两个）的风险。一般建议主节点为偶数的时间不要超过1小时。</li><li>在已有集群的情况下，注意不要让 Keeplived 在没有主节点功能的节点上启动。否则有可能其会竞争为当前的工作主节点，导致整个集群无法访问。</li><li>应该先添加节点后再进行删除。</li></ul><p>首先注意主节点不能用<code>delete node</code>，移除可能需要<code>kubectl drain</code>(维护模式)。错误操作或者主节点意外失效，主节点的相关信息仍然会保存在 etcd 里。</p><p>需要进入 etcd pod 操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl -w table endpoint --cluster status</span><br><span class="line"></span><br><span class="line">//这个命令会列出当前主节点，然后选择要移除的移除</span><br><span class="line">ETCDCTL_API=3 etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key member list</span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key member remove &lt;id&gt;</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>pause 的镜像地址定义在 containerd 配置中</li><li>containerd 的 config.toml 可以配置镜像源</li></ul><h1 id="常用维护命令"><a href="#常用维护命令" class="headerlink" title="常用维护命令"></a>常用维护命令</h1><p>列出 default 下的所有 pods</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n default -o wide</span><br></pre></td></tr></table></figure><p>删除一个 pod (通常会自己重启)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod &lt;podname&gt; -n default</span><br></pre></td></tr></table></figure><p>批量删pods的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n default |grep &quot;Error&quot; |awk &#x27;&#123;print $1&#125;&#x27; |xargs kubectl delete pod</span><br></pre></td></tr></table></figure><p>不过如果机器对 grep 用 alias 显示行号，会需要<code>unalias grep</code></p><h2 id="crictl"><a href="#crictl" class="headerlink" title="crictl"></a>crictl</h2><p>crictl 是为 Kubernetes 设计的，通过 CRI (Container Runtime Interface) 标准与任何兼容的容器运行时（如 containerd, CRI-O）交互。它是跨运行时的调试工具。</p><p><strong>列出所有 pods</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl pods</span><br></pre></td></tr></table></figure><p><strong>列出镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl images</span><br></pre></td></tr></table></figure><p><strong>下载镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl pull &lt;image-name&gt;</span><br></pre></td></tr></table></figure><p><strong>crictl 只支持下载删除镜像，但不支持 tag、build 等功能</strong></p><p><strong>查看容器 log</strong><br>下面是 containerid ，不是名字，也不是pod id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl  logs &lt;containerid&gt;</span><br></pre></td></tr></table></figure><h3 id="runtime-endpoint"><a href="#runtime-endpoint" class="headerlink" title="runtime-endpoint"></a>runtime-endpoint</h3><p>runtime-endpoint 是容器运行时（如 containerd, CRI-O）暴露其 CRI 服务的通信地址，<code>--runtime-endpoint</code>用于指定 crictl 工具需要连接的、实现了容器运行时接口（CRI）的 gRPC 服务的监听地址。目前不写也没事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">containerd: unix:///run/containerd/containerd.sock</span><br><span class="line"></span><br><span class="line">CRI-O: unix:///var/run/crio/crio.sock</span><br><span class="line"></span><br><span class="line">dockershim (在 Kubernetes v1.24+ 中已移除): unix:///var/run/dockershim.sock</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl --runtime-endpoint unix:///run/containerd/containerd.sock ps -a</span><br></pre></td></tr></table></figure><h2 id="ctr"><a href="#ctr" class="headerlink" title="ctr"></a>ctr</h2><p>ctr 是 containerd 项目自带的原生客户端，直接与 containerd 的 API 交互，绕过了 CRI 层。它只适用于 containerd，并且功能更底层。</p><p>在 Kubernetes 环境中，containerd 会为 Kubelet 创建一个名为 k8s.io 的命名空间。因此，使用 ctr 查看 K8s管理的资源时，必须指定该命名空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ctr -n k8s.io images <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>其他还包括 <code>images tag</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat harbor.v2.14.1.tar.gz | <span class="built_in">sudo</span> ctr -n k8s.io images import -</span><br></pre></td></tr></table></figure><p>(docker 支持tgz,ctr只支持tar)</p><p>这些用来替代<code>docker</code>的命令</p><h2 id="nerdctl"><a href="#nerdctl" class="headerlink" title="nerdctl"></a>nerdctl</h2><p>是 containerd 的另一个客户端工具。它的目标是提供一个与 Docker CLI 完全兼容的体验。</p><p>未测试</p><p>看了下，目前是需要自己下 bin 文件使用，还涉及到 docker-buildx, debian 目前还不建议用。其它系统自行调研下好了</p><h2 id="其他维护命令"><a href="#其他维护命令" class="headerlink" title="其他维护命令"></a>其他维护命令</h2><p>查看报错，通常用于确认节点的异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo journalctl -u kubelet -f --no-pager</span><br></pre></td></tr></table></figure><hr><p>helm ctr 命令说明更新 -<time datetime="2026-02-08">2026-02-08</time></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;没空系统性整理，所以先记笔记好了&lt;/p&gt;
&lt;h1 id=&quot;最新版的Kubernetes-已不再使用-Docker&quot;&gt;&lt;a href=&quot;#最新版的Kubernetes-已不再使用-Docker&quot; class=&quot;headerlink&quot; title=&quot;最新版的Kubernetes</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="Notes" scheme="http://ted423.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>硬件相关的一些笔记</title>
    <link href="http://ted423.github.io/Hardware/HardwareNotes/"/>
    <id>http://ted423.github.io/Hardware/HardwareNotes/</id>
    <published>2025-11-27T06:16:27.477Z</published>
    <updated>2025-11-27T06:35:42.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intel-Network"><a href="#Intel-Network" class="headerlink" title="Intel Network"></a>Intel Network</h1><p>这是一个集成包</p><p><a href="https://www.intel.com/content/www/us/en/download/15084/intel-ethernet-adapter-complete-driver-pack.html">https://www.intel.com/content/www/us/en/download/15084/intel-ethernet-adapter-complete-driver-pack.html</a></p><p>10GiB 网卡 X540 因为是比较型号老的，最后的驱动日期是2020年的，其只能手动安装。不支持 2.5 GiB 模式。</p><p>只建议在 Linux 下使用，Windows 下驱动已经不更新了</p><h1 id="Intel-R-Serial-IO-GPIO"><a href="#Intel-R-Serial-IO-GPIO" class="headerlink" title="Intel(R) Serial IO GPIO"></a>Intel(R) Serial IO GPIO</h1><p>Intel(R) Serial IO GPIO 控制器驱动在 Intel 官网没有提供，且 Windows Update 通常不推送</p><p>该驱动分发依赖 OEM 厂商定制，而非 Intel 直接提供</p><p>一方面是OEM 定制化主导</p><p>Intel 将此类驱动（如 GPIO&#x2F;I2C 主机控制器）视为芯片组配套组件，授权给设备制造商（如 Dell、Lenovo、ASUS）进行适配和分发。用户需通过电脑品牌的官方支持页面获取驱动，例如：</p><ul><li>Dell 为特定机型提供专用版本（版本号 30.100.2020.7）；</li><li>Lenovo 要求先安装主板芯片组驱动，再装 Serial IO 驱动（仅支持指定机型如 ThinkPad Helix）。</li></ul><p>另一方面硬件 ID 绑定严格，硬件 ID（如 ACPI\INT345D）深度关联，不同主板型号（如 100 系列与 300 系列芯片组）需匹配不同驱动版本。若用户未按硬件 ID 精确搜索，在 Intel 官网难以定位正确驱动。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="DDR5-内存"><a href="#DDR5-内存" class="headerlink" title="DDR5 内存"></a>DDR5 内存</h2><p>DDR5内存将传统的64位位宽拆分为两个独立的32位子通道（称为双子通道），因此单条DDR5即可实现类似双通道的带宽效果。例如，单条DDR5 4800MHz的理论带宽为38.4 GB&#x2F;s（32位×2通道），而DDR4单通道仅25.6 GB&#x2F;s（64位单通道）。</p><p>插满四根DDR5可能导致频率下降（如4800MHz降至4000MHz），带宽反而比双条降低15%~20%，延迟增加25%。</p><p>目前绝大多数消费级的DDR5主板都采用一种叫做“菊花链”（Daisy Chain）的布线方式。CPU的内存控制器设计时，通常会对两根内存插槽的信号线路做专门优化，以实现最高的频率和最稳定的运行。当插上四根内存时，相当于内存控制器需要同时管理四条“通道”的信号。这会大大增加控制器的负载和电气压力，导致信号衰减和干扰（Crosstalk）变得更严重。离CPU最近的两个内存插槽（通常是A2和B2）是“主要出口”，信号路径最短，最干净。另外两个插槽（A1和B1），信号需要绕更远的路，质量会下降。在高频情况下不稳定，为了保证四条路都能同步稳定，整个系统的速度就必须被拉低到最差的水平。</p><p>所有DDR5 DRAM芯片都具备 On-Die ECC，仅用于内部，不是传统的系统级ECC（不会将错误报告给CPU或操作系统）。</p><h2 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h2><p>Unbuffered ECC （非缓冲ECC）和 Registered ECC（注册式ECC）</p><p>Unbuffered ECC内存指的是不带缓冲（unbuffered）的纠错码（Error-Correcting Code）内存模块。它在标准内存基础上添加了额外的位（通常是1&#x2F;8的额外容量）来检测和纠正单比特错误，从而提高数据完整性和可靠性，但没有额外的缓冲芯片来管理信号。 与registered（或buffered）ECC相比，unbuffered ECC的命令直接从内存控制器传输到模块，没有中间寄存器延迟，因此速度更快，但通常支持的内存通道或模块数量较少，适用于桌面、工作站或小型服务器，而非大规模企业级系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intel-Network&quot;&gt;&lt;a href=&quot;#Intel-Network&quot; class=&quot;headerlink&quot; title=&quot;Intel Network&quot;&gt;&lt;/a&gt;Intel Network&lt;/h1&gt;&lt;p&gt;这是一个集成包&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="Hardware" scheme="http://ted423.github.io/categories/Hardware/"/>
    
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="Hardware" scheme="http://ted423.github.io/tags/Hardware/"/>
    
    <category term="Notes" scheme="http://ted423.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Debian 错误 deb 打包卸载处理</title>
    <link href="http://ted423.github.io/Issue/Errordeb/"/>
    <id>http://ted423.github.io/Issue/Errordeb/</id>
    <published>2025-11-27T06:05:32.021Z</published>
    <updated>2025-11-27T06:09:43.329Z</updated>
    
    <content type="html"><![CDATA[<p>主要是自打包的配置没写好，没法升级，没法重装卸载时配置没法处理导致的不可卸载。</p><p>删除这个文件夹下的<code>/var/lib/dpkg/info/</code>相关文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --remove --force-all &lt;包名&gt;</span><br></pre></td></tr></table></figure><p>其实建议再仔细看下包的源码，然后尝试还原下里面修改的配置，避免潜在影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要是自打包的配置没写好，没法升级，没法重装卸载时配置没法处理导致的不可卸载。&lt;/p&gt;
&lt;p&gt;删除这个文件夹下的&lt;code&gt;/var/lib/dpkg/info/&lt;/code&gt;相关文件&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="Issue" scheme="http://ted423.github.io/categories/Issue/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Issue" scheme="http://ted423.github.io/tags/Issue/"/>
    
  </entry>
  
  <entry>
    <title>Ububtu Server 踩坑笔记</title>
    <link href="http://ted423.github.io/Linux/Ubuntu_Server_%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://ted423.github.io/Linux/Ubuntu_Server_%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</id>
    <published>2025-11-21T01:25:53.851Z</published>
    <updated>2025-11-21T02:14:19.665Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu Desktop 用的 NetworkManager，个人不太喜欢就想尝试下 Server，Ubuntu Server 用的 systemd-networkd.</p><ol><li>Win Server DHCP 的兼容性问题，ipv4 也会 DUID 优先，而 Linux 系的可以处理好，只接受 MAC(未经查证)。</li><li>默认查到的都告诉你改 Nekworkd 配置，而实际上 Ubuntu 用 Netplan，改相关配置是没用的。</li><li>Ubuntu Server 默认 Netplan 配置不写 renderer，而必须要<code>renderer: networkd</code>，才能<code>dhcp-identifier: mac</code></li><li>Ubuntu 的桌面默认都带 NetworkManager，不过因为renderer，是写好的，应该问题不大，不过保险起见，不装为好。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Ubuntu Desktop 用的 NetworkManager，个人不太喜欢就想尝试下 Server，Ubuntu Server 用的 systemd-networkd.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Win Server DHCP 的兼容性问题，ipv4 也会 DUID 优</summary>
      
    
    
    
    <category term="Document" scheme="http://ted423.github.io/categories/Document/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="Ubuntu" scheme="http://ted423.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下硬件检测工具</title>
    <link href="http://ted423.github.io/Hardware/test/"/>
    <id>http://ted423.github.io/Hardware/test/</id>
    <published>2025-11-20T03:55:59.564Z</published>
    <updated>2025-11-21T01:26:43.566Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下基本看不到 USB 硬盘盒里接的硬盘的 SMART，Windows 下可以。</p><h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><p>KDE Gnome 都有自带的硬盘信息查看工具，一般来说 gparted 也能看</p><h1 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h1><h2 id="hdparm"><a href="#hdparm" class="headerlink" title="hdparm"></a>hdparm</h2><p>hdparm 是一个底层的硬盘工具。测试过程中会绕过文件系统，直接测试块设备</p><p>hdparm -Tt &#x2F;dev&#x2F;sdb1</p><h2 id="fio-cdm"><a href="#fio-cdm" class="headerlink" title="fio-cdm"></a>fio-cdm</h2><p>注意就是很长时间没更新了，其需要手动安装 fio (这个是长期维护的)。</p><p><a href="https://github.com/xlucn/fio-cdm">https://github.com/xlucn/fio-cdm</a></p><h2 id="stress-ng"><a href="#stress-ng" class="headerlink" title="stress-ng"></a>stress-ng</h2><p><a href="https://github.com/ColinIanKing/stress-ng">https://github.com/ColinIanKing/stress-ng</a></p><p>这个是支持各种硬件的压力测试，不过我主要拿来测内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo stress-ng --vm 100 --vm-bytes 2G --timeout 180</span><br></pre></td></tr></table></figure><p>另似乎这个命令版本参数上有差异，IC 内部 CentOS7 下 vm-bytes 是每个 vm 使用，而在 Ubuntu 24.04 LTS 上，可能是总量，htop能观察到每个进程自动申请了相应的内存（10，200 每个进程申请了20GiB）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux 下基本看不到 USB 硬盘盒里接的硬盘的 SMART，Windows 下可以。&lt;/p&gt;
&lt;h1 id=&quot;GUI&quot;&gt;&lt;a href=&quot;#GUI&quot; class=&quot;headerlink&quot; title=&quot;GUI&quot;&gt;&lt;/a&gt;GUI&lt;/h1&gt;&lt;p&gt;KDE Gnome 都有自</summary>
      
    
    
    
    <category term="Hardware" scheme="http://ted423.github.io/categories/Hardware/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Document" scheme="http://ted423.github.io/tags/Document/"/>
    
    <category term="Hardware" scheme="http://ted423.github.io/tags/Hardware/"/>
    
    <category term="建设中" scheme="http://ted423.github.io/tags/%E5%BB%BA%E8%AE%BE%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>[文本编辑器] Notepad4</title>
    <link href="http://ted423.github.io/Software/Document&amp;Texteditor/notepad4/"/>
    <id>http://ted423.github.io/Software/Document&amp;Texteditor/notepad4/</id>
    <published>2025-10-23T16:36:51.894Z</published>
    <updated>2025-10-23T16:46:54.962Z</updated>
    
    <content type="html"><![CDATA[<p>4 其实也是继承 notepad2, 又名Notepad2⨯2, Notepad2++，国人开发。甚至原生做了简繁转换的功能。</p><p>可惜代码格式化这块似乎没做完。</p><p><a href="https://github.com/zufuliu/notepad4/issues/614#issuecomment-2088217105">https://github.com/zufuliu/notepad4/issues/614#issuecomment-2088217105</a></p><p>3 其实也还在维护</p><p><a href="https://github.com/zufuliu/notepad4">https://github.com/zufuliu/notepad4</a></p><p>release 有点猛</p><p>就是只有便携版，没有安装包。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;4 其实也是继承 notepad2, 又名Notepad2⨯2, Notepad2++，国人开发。甚至原生做了简繁转换的功能。&lt;/p&gt;
&lt;p&gt;可惜代码格式化这块似乎没做完。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zufuliu/notepad</summary>
      
    
    
    
    <category term="Software" scheme="http://ted423.github.io/categories/Software/"/>
    
    
    <category term="Windows" scheme="http://ted423.github.io/tags/Windows/"/>
    
    <category term="开源(Open Source)" scheme="http://ted423.github.io/tags/%E5%BC%80%E6%BA%90-Open-Source/"/>
    
    <category term="3-clause BSD license" scheme="http://ted423.github.io/tags/3-clause-BSD-license/"/>
    
    <category term="Document&amp;Texteditor" scheme="http://ted423.github.io/tags/Document-Texteditor/"/>
    
  </entry>
  
  <entry>
    <title>学习新名词 Help Vampires (帮助吸血鬼)</title>
    <link href="http://ted423.github.io/etc/Help.Vampires/"/>
    <id>http://ted423.github.io/etc/Help.Vampires/</id>
    <published>2025-10-10T14:39:06.253Z</published>
    <updated>2025-10-10T14:42:44.476Z</updated>
    
    <content type="html"><![CDATA[<p>偶然间看到的</p><p>“Help Vampires”（求助吸血鬼）是一个在技术、开发、开源社区以及任何需要他人协助的领域中非常常见的、用来形容特定类型求助者的术语。它形象地比喻那些在寻求帮助时，无意识或有意识地消耗他人时间、精力、耐心和生产力，却不付出同等努力去解决问题或学习新知识的人。</p><p>简单来说，“Help Vampire”就是那种只会提问，从不尝试自己解决问题，或者即使得到了答案和指导也从不学习和进步的求助者。 他们像无底洞一样，不断地“吸取”帮助者的资源，却不产生任何价值，反而让帮助者感到疲惫和沮丧。</p><p><strong>“Help Vampire”的行为特征（如何识别）：</strong></p><ol><li><p><strong>不事先尝试解决问题 (No Prior Effort):</strong></p><ul><li>问题一出现就立刻求助，甚至没有尝试谷歌搜索、查阅文档或自己动手调试。</li><li>他们会问一些通过简单搜索就能找到答案的问题。</li></ul></li><li><p><strong>重复提问 (Repeated Questions):</strong></p><ul><li>在相同或类似的问题上，他们会反复寻求帮助，即使之前已经得到过指导。</li><li>这表明他们没有从过去的帮助中学习。</li></ul></li><li><p><strong>期待他人代劳 (Expect Others to Do the Work):</strong></p><ul><li>他们不仅仅是寻求建议或方向，而是希望别人直接给出一个完整的解决方案，甚至代他们完成任务。</li><li>例如，问“我的代码不工作，你能帮我写一个吗？”而不是“我的代码在这里出了问题，我尝试了X和Y，但没有成功，你能帮我看看思路哪里不对吗？”</li></ul></li><li><p><strong>不提供足够的信息 (Lack of Context&#x2F;Information):</strong></p><ul><li>提问时语焉不详，不提供错误信息、代码片段、环境配置等必要背景信息，让帮助者难以诊断问题。</li><li>当被要求提供更多信息时，他们可能会感到不耐烦或不理解。</li></ul></li><li><p><strong>不听取或不采纳建议 (Ignore Advice):</strong></p><ul><li>当帮助者给出解决方案或指出学习路径时，他们不予理睬，或者只是机械地执行，而不理解其背后的原理。</li><li>很快又会带着一个类似的问题回来。</li></ul></li><li><p><strong>把简单问题复杂化 (Over-complicate Simple Issues):</strong></p><ul><li>对于一些基本概念或常见问题，他们可能会把它描述成一个极其复杂、无法理解的难题，以此来合理化自己不愿尝试的借口。</li></ul></li><li><p><strong>不尊重他人时间 (Disregard for Others&#39; Time):</strong></p><ul><li>他们认为别人的时间是理所当然可以被自己消耗的，不考虑帮助者可能正在忙碌，或者没有义务无休止地提供免费服务。</li></ul></li></ol><p><strong>“Help Vampire”产生的原因（不一定是恶意）：</strong></p><ul><li><strong>缺乏信心或恐惧失败：</strong> 害怕自己尝试会犯错，所以宁愿依赖他人。</li><li><strong>懒惰：</strong> 寻求帮助比自己思考和动手要省力。</li><li><strong>缺乏解决问题的能力：</strong> 真的不知道如何开始调查问题，但也没有意识到需要学习这种能力。</li><li><strong>误解求助的本质：</strong> 认为求助就是为了得到答案，而不是为了学习解决问题的方法。</li><li><strong>过去成功的经验：</strong> 以前总有人替他们解决问题，形成了依赖。</li></ul><p><strong>“Help Vampire”带来的危害：</strong></p><ul><li><strong>消耗帮助者的精力：</strong> 导致帮助者疲惫、沮丧，降低生产力。</li><li><strong>打击帮助者的积极性：</strong> 长此以往，帮助者会变得不愿再提供帮助。</li><li><strong>阻碍求助者自身成长：</strong> 求助者永远无法真正掌握知识和技能，缺乏独立解决问题的能力。</li><li><strong>损害社区氛围：</strong> 如果一个社区或团队中“Help Vampire”过多，会导致互助精神减弱，甚至产生负面情绪。</li></ul><p><strong>如何应对“Help Vampire”：</strong></p><ol><li><strong>引导而非直接给出答案：</strong> 当他们寻求帮助时，不要直接给答案，而是询问他们“你已经尝试了什么？”、“你谷歌搜索了什么关键词？”、“你查阅了哪些文档？”。</li><li><strong>提供学习资源和方法：</strong> 指引他们去查阅文档、教程或推荐一些学习网站，教他们如何找到答案，而不是直接提供答案。</li><li><strong>设定界限：</strong> 明确自己的时间限制和帮助范围。例如：“我很乐意帮你看看这个问题，但请你先尝试自己解决15分钟。”</li><li><strong>自动化&#x2F;标准化：</strong> 如果是常见问题，可以编写FAQ、文档或制作模板，让求助者先查阅。</li><li><strong>温和地拒绝或转移：</strong> 当他们提出不合理的要求时，可以礼貌地拒绝，或将他们引导到更合适的帮助渠道（如官方论坛、文档）。</li><li><strong>鼓励独立思考：</strong> 强调解决问题的过程和学习的重要性，而不仅仅是得到一个结果。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;偶然间看到的&lt;/p&gt;
&lt;p&gt;“Help Vampires”（求助吸血鬼）是一个在技术、开发、开源社区以及任何需要他人协助的领域中非常常见的、用来形容特定类型求助者的术语。它形象地比喻那些在寻求帮助时，无意识或有意识地消耗他人时间、精力、耐心和生产力，却不付出同等努力去解决问</summary>
      
    
    
    
    <category term="etc" scheme="http://ted423.github.io/categories/etc/"/>
    
    
    <category term="个人观点" scheme="http://ted423.github.io/tags/%E4%B8%AA%E4%BA%BA%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>NFS 相关</title>
    <link href="http://ted423.github.io/Linux/nfs_something/"/>
    <id>http://ted423.github.io/Linux/nfs_something/</id>
    <published>2025-10-01T07:34:39.005Z</published>
    <updated>2026-01-21T13:31:57.633Z</updated>
    
    <content type="html"><![CDATA[<p>只考虑 NFSv4，NFSv4 强制要求 TCP </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.aws.amazon.com/efs/latest/ug/mounting-fs-nfs-mount-settings.html">https://docs.aws.amazon.com/efs/latest/ug/mounting-fs-nfs-mount-settings.html</a></p><h1 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h1><p>后台挂载</p><p>如果第一次挂载失败，转入后台继续尝试，不阻塞前台启动过程。这个涉及到有时候网络没那么快好，不使用的情况下，一定情况下可能出现启动完后没挂载的情况或者直接就起不来。</p><h1 id="fsc"><a href="#fsc" class="headerlink" title="fsc"></a>fsc</h1><p>本地缓存，需要另一个软件支持，使用中有点问题。最后没用了</p><h1 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h1><p>行为：当 NFS 服务器不可达时，客户端会无限期不断重试 I&#x2F;O 请求，直到服务器恢复正常为止。程序会“停住”不动，等待恢复后继续正常运行。</p><p><del>常与 intr 或其替代选项一起使用，使挂载操作可中断（尤其在老内核中），避免客户端彻底卡死。</del>(但是 intr 在 内核 2.6.25 开始废弃，2008 年，RHEL6 开始)</p><p>通常 如果 nfs 挂载的是重要数据盘，一般是 hard。<strong>硬挂载将保持数据一致性</strong></p><h1 id="soft"><a href="#soft" class="headerlink" title="soft"></a>soft</h1><p>客户端在发起 I&#x2F;O 请求后，如果在一定重试次数或超时时间内未收到服务器响应，就会返回错误给应用程序，而不是一直等下去。</p><p>可设置 timeo（超时时间），retrans（最大重发次数），让挂载更具灵活性</p><p>一般建议是只读挂载才使用软挂载。</p><h1 id="async-sync"><a href="#async-sync" class="headerlink" title="async &amp; sync"></a>async &amp; sync</h1><p>async 会先进内存，有比较好的性能，但是断电会有问题，sync 不进内存，但是性能会有比较严重的问题。Gemini 是说 zfs 有写缓存的情况下强烈建议使用 sync。</p><p><strong>这个参数同时在客户端和服务端都可以配置，且只影响被配置的机子，async 在客户端配置则只影响客户端是否落盘</strong></p><h1 id="timeo-retrans"><a href="#timeo-retrans" class="headerlink" title="timeo &amp; retrans"></a>timeo &amp; retrans</h1><p>硬挂载一般使用默认值就可以，软挂载特别是 timeo 可能需要设短一点，否则会产生超长时间的卡顿后才报错。</p><p>而硬挂载，因为会不断重试，本身就会一直卡顿。</p><p>另外需要注意的是，早期 NFS 是使用 UDP 的，很多教程会与混淆，而在 NFSv4 中，只是用 TCP，需要考虑 TCP 自身的 timeout 情况。</p><h1 id="NFS-Server-命令"><a href="#NFS-Server-命令" class="headerlink" title="NFS Server 命令"></a>NFS Server 命令</h1><ul><li><code>exportfs -ra</code> nfs server 刷新配置而不用重启</li><li><code>exportfs -v</code> 查看客户端挂载参数</li></ul><h1 id="NFS-Server-端参数"><a href="#NFS-Server-端参数" class="headerlink" title="NFS Server 端参数"></a>NFS Server 端参数</h1><h1 id="wdelay-no-wdelay"><a href="#wdelay-no-wdelay" class="headerlink" title="wdelay &amp; no_wdelay"></a>wdelay &amp; no_wdelay</h1><p>配置 async 的时候没法使用 no_wdelay，高并发写入时不建议开 wdelay，no_wdelay建议配合 sync 使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;只考虑 NFSv4，NFSv4 强制要求 TCP &lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.aws.ama</summary>
      
    
    
    
    <category term="Linux" scheme="http://ted423.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://ted423.github.io/tags/Linux/"/>
    
    <category term="Software" scheme="http://ted423.github.io/tags/Software/"/>
    
    <category term="Notes" scheme="http://ted423.github.io/tags/Notes/"/>
    
  </entry>
  
</feed>
